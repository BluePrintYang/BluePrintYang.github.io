<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《MySQL必知必会》总结</title>
    <url>/2020/06/27/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="mysql"><a class="header-anchor" href="#mysql"></a>MySQL</h2>
<p>行：表中的一个记录</p>
<p>主键（primary key）：一列（或一组列），其值能唯一区分表中每个行</p>
<h3 id="使用mysql"><a class="header-anchor" href="#使用mysql"></a>使用MySQL</h3>
<p>展示所有数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>选择数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crashcourse;</span><br></pre></td></tr></table></figure>
<p>获取一个数据库内的表的列表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>
<p>显示表列，需要给出表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> customers;</span><br><span class="line"><span class="comment">-- 下面语句等价</span></span><br><span class="line"><span class="keyword">describe</span> customers;</span><br></pre></td></tr></table></figure>
<p>其他show语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span>;	<span class="comment">-- 显示广泛的服务器状态信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span>;	<span class="comment">-- 显示创建特定数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span>;	<span class="comment">-- 显示创建特定表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span>;	<span class="comment">-- 显示授予用户的安全权限</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">errors</span>;	<span class="comment">-- 显示服务器错误</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">warnings</span>;	<span class="comment">--显示服务器警告</span></span><br></pre></td></tr></table></figure>
<p>进一步了解show</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">help</span> <span class="keyword">show</span>;</span><br></pre></td></tr></table></figure>
<h3 id="检索数据"><a class="header-anchor" href="#检索数据"></a>检索数据</h3>
<h4 id="select语句"><a class="header-anchor" href="#select语句"></a>select语句</h4>
<p>检索单个列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure>
<p>检索多个列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_name <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure>
<p>检索所有列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure>
<p>检索不同的行（数据不重复）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> vend_id <span class="keyword">from</span> products;	<span class="comment">-- distinct放在列名前面</span></span><br></pre></td></tr></table></figure>
<p>限制结果</p>
<h5 id="limit子句"><a class="header-anchor" href="#limit子句"></a>LIMIT子句</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">limit</span> <span class="number">5</span>;	<span class="comment">-- 只返回前5行数据，不够5行则返回所有数据</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">limit</span> <span class="number">5</span>,<span class="number">5</span>;	<span class="comment">-- 返回从行5开始的5行，第一个数为开始位置，第二个数为行数</span></span><br></pre></td></tr></table></figure>
<p>==第一行为行0==</p>
<p>使用完全限定的表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> products.prod_name <span class="keyword">from</span> products;</span><br><span class="line"><span class="keyword">select</span> products.prod_name <span class="keyword">from</span> crashcourse.products;</span><br></pre></td></tr></table></figure>
<h3 id="检索排序数据"><a class="header-anchor" href="#检索排序数据"></a>检索排序数据</h3>
<h4 id="排序数据"><a class="header-anchor" href="#排序数据"></a>排序数据</h4>
<h5 id="order-by子句"><a class="header-anchor" href="#order-by子句"></a>ORDER BY子句</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>按多个列排序</p>
<blockquote>
<p>首先按prod_price排序，prod_price相同才按prod_name</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_price, prod_name;</span><br></pre></td></tr></table></figure>
<p>指定排序方向</p>
<blockquote>
<p>默认升序(ASC)，使用DESC关键字降序</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_price <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>先按prod_price降序，再按prod_name升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_price <span class="keyword">DESC</span>, prod_name;</span><br></pre></td></tr></table></figure>
<h3 id="过滤数据"><a class="header-anchor" href="#过滤数据"></a>过滤数据</h3>
<h4 id="使用where子句"><a class="header-anchor" href="#使用where子句"></a>使用WHERE子句</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_price = <span class="number">2.50</span>;</span><br></pre></td></tr></table></figure>
<h4 id="where子句操作符"><a class="header-anchor" href="#where子句操作符"></a>where子句操作符</h4>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在指定两个值之间</td>
</tr>
</tbody>
</table>
<h4 id="范围值检查"><a class="header-anchor" href="#范围值检查"></a>范围值检查</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="空值检查"><a class="header-anchor" href="#空值检查"></a>空值检查</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h3 id="数据过滤"><a class="header-anchor" href="#数据过滤"></a>数据过滤</h3>
<h4 id="组合where子句"><a class="header-anchor" href="#组合where子句"></a>组合where子句</h4>
<blockquote>
<p>允许给出多个where子句，子句之间用AND或OR联结</p>
</blockquote>
<h5 id="and操作符"><a class="header-anchor" href="#and操作符"></a>AND操作符</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> vend_id = <span class="number">1003</span> <span class="keyword">AND</span> prod_price &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h5 id="or操作符"><a class="header-anchor" href="#or操作符"></a>OR操作符</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> vend_id = <span class="number">1002</span> <span class="keyword">OR</span> vend_id = <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>
<h5 id="计算次序"><a class="header-anchor" href="#计算次序"></a>计算次序</h5>
<p>对于下面的语句，优先处理AND操作符（AND操作符在计算次序中优先级更高）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> vend_id = <span class="number">1002</span> <span class="keyword">OR</span> vend_id = <span class="number">1003</span> <span class="keyword">AND</span> prod_price &gt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>如果需要先计算OR联结的语句，需要加括号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> (vend_id = <span class="number">1002</span> <span class="keyword">OR</span> vend_id = <span class="number">1003</span>) <span class="keyword">AND</span> prod_price &gt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h5 id="in操作符"><a class="header-anchor" href="#in操作符"></a>IN操作符</h5>
<blockquote>
<p>in用来指定条件范围</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">in</span>(<span class="number">1002</span>,<span class="number">1003</span>) <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>
<h5 id="not操作符"><a class="header-anchor" href="#not操作符"></a>NOT操作符</h5>
<blockquote>
<p>否定后面的条件</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_price, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">not</span> <span class="keyword">in</span>(<span class="number">1002</span>,<span class="number">1003</span>) <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>
<h3 id="用通配符过滤"><a class="header-anchor" href="#用通配符过滤"></a>用通配符过滤</h3>
<h4 id="like操作符"><a class="header-anchor" href="#like操作符"></a>LIKE操作符</h4>
<h5 id="通配符"><a class="header-anchor" href="#通配符"></a>%通配符</h5>
<blockquote>
<p>表示任何字符出现任何次数</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">'jet%'</span>;</span><br></pre></td></tr></table></figure>
<h5 id="通配符-v2"><a class="header-anchor" href="#通配符-v2"></a>_通配符</h5>
<blockquote>
<p>匹配单个任意字符</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">'_ ton anvil'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用通配符技巧"><a class="header-anchor" href="#使用通配符技巧"></a>使用通配符技巧</h4>
<ul>
<li>不要过度使用通配符。优先使用其他能达到相同目的的操作符。</li>
<li>除非绝对有必要，否则不要把通配符放在搜索模式的开始处。这样搜索起来是最慢的</li>
<li>仔细注意通配符的位置</li>
</ul>
<h3 id="使用正则表达式进行搜索"><a class="header-anchor" href="#使用正则表达式进行搜索"></a>使用正则表达式进行搜索</h3>
<h4 id="基本字符匹配"><a class="header-anchor" href="#基本字符匹配"></a>基本字符匹配</h4>
<blockquote>
<p>检索文本包含1000的所有行</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'1000'</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>与使用like关键词的语句非常像，只不过把like改为了regexp</p>
<p>==但是like匹配整个列值，一般需要搭配通配符使用==</p>
<p>.000中 . 表示匹配任意一个字符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'.000'</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>正则表达式匹配不区分大小写，如果需要区分，则在regexp后面添加binary关键字</p>
<h4 id="进行or匹配"><a class="header-anchor" href="#进行or匹配"></a>进行OR匹配</h4>
<blockquote>
<p>搜索两个串之一，使用|，可以给出两个以上的OR条件</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'1000|2000'</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>
<h4 id="匹配几个字符之一"><a class="header-anchor" href="#匹配几个字符之一"></a>匹配几个字符之一</h4>
<blockquote>
<p>使用一组用[和]括起来的字符</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'[123] Ton'</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>[^123]则匹配除这些字符以外的任意字符</p>
<h4 id="匹配范围"><a class="header-anchor" href="#匹配范围"></a>匹配范围</h4>
<p><strong>[0123456789]可简写为[0-9]</strong></p>
<h4 id="匹配特殊字符"><a class="header-anchor" href="#匹配特殊字符"></a>匹配特殊字符</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加\\为前导 \\-表示查找- ， \\.表示查找.</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\\f</td>
<td>换页</td>
</tr>
<tr>
<td>\\n</td>
<td>换行</td>
</tr>
<tr>
<td>\\r</td>
<td>回车</td>
</tr>
<tr>
<td>\\t</td>
<td>制表</td>
</tr>
<tr>
<td>\\v</td>
<td>纵向制表</td>
</tr>
</tbody>
</table>
<p>==为了匹配\本身，需要使用\\\==</p>
<h4 id="匹配字符类"><a class="header-anchor" href="#匹配字符类"></a>匹配字符类</h4>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>任意字母和数字（同[a-zA-Z0-9]）</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>任意字符（同[a-zA-Z]）</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格和制表（同[\\t]）</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>ASCII控制字符（ASCII0到31和127）</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>任意数字（同[0-9]）</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>与[:print:]相同，但不包含空格</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>任意小写字母（同[a-z]）</td>
</tr>
<tr>
<td>[:print:]</td>
<td>任意可打印字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>
</tr>
<tr>
<td>[:space:]</td>
<td>包括空格在内的任意空白字符（同[\\\f\\n\\r\\t\\v]）</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>任意大写字母（同[A-Z]）</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>任意十六进制数字（同[a-fA-F0-9]）</td>
</tr>
</tbody>
</table>
<h4 id="匹配多个实例"><a class="header-anchor" href="#匹配多个实例"></a>匹配多个实例</h4>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>0个或多个匹配</td>
</tr>
<tr>
<td>+</td>
<td>1个或多个匹配（等于{1,}）</td>
</tr>
<tr>
<td>?</td>
<td>0个或1个匹配（等于{0,1}）</td>
</tr>
<tr>
<td>{n}</td>
<td>指定数目的匹配</td>
</tr>
<tr>
<td>{n,}</td>
<td>不少于指定数目的匹配</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配数目的范围（m不超过255）</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'\\([0-9] sticks?\\)'</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>
<p>输出示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TNT (1 stick)</span><br><span class="line">TNT (5 sticks)</span><br></pre></td></tr></table></figure>
<p>分析：\\( 匹配 ( ,[0-9]匹配任意数字，sticks?匹配stick和sticks，\\)匹配)</p>
<h4 id="定位符"><a class="header-anchor" href="#定位符"></a>定位符</h4>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>文本的开始</td>
</tr>
<tr>
<td>$</td>
<td>文本的结尾</td>
</tr>
<tr>
<td>[[:&lt;:]]</td>
<td>词的开始</td>
</tr>
<tr>
<td>[[:&gt;:]]</td>
<td>词的结尾</td>
</tr>
</tbody>
</table>
<p>如果想要找出以一个数（包括以小数点开始的数）<strong>开始</strong>的所有产品，使用[0-9\\.]不行，因为它在文本内任意位置查找匹配。解决方法是使用定位符^</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'^[0-9\\.]'</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></figure>
<p><strong>^的双重用途</strong>：在集合中，用它来否定该集合，否则用来指串的开始处</p>
<h3 id="创建计算字段"><a class="header-anchor" href="#创建计算字段"></a>创建计算字段</h3>
<blockquote>
<p>计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。</p>
</blockquote>
<p><strong>字段</strong>：基本上与列的意思相同</p>
<h4 id="拼接字段"><a class="header-anchor" href="#拼接字段"></a>拼接字段</h4>
<blockquote>
<p>拼接：将值联结到一起构成单个值</p>
</blockquote>
<p>在MySQL的SELECT语句中，可使用**==Concat()函数==**来拼接两个列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Concat</span>(vend_name,<span class="string">'('</span>,vend_country,<span class="string">')'</span>) <span class="keyword">from</span> vendors <span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br></pre></td></tr></table></figure>
<p>Trim()函数：去除串左右两边的空格</p>
<p>LTrim()：去除左边的空格	RTrim()：去除右边的空格</p>
<p><strong>使用别名</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Concat</span>(vend_name,<span class="string">'('</span>,vend_country,<span class="string">')'</span>) <span class="keyword">as</span> vend_title <span class="keyword">from</span> vendors <span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br></pre></td></tr></table></figure>
<h4 id="执行算术计算"><a class="header-anchor" href="#执行算术计算"></a>执行算术计算</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id,</span><br><span class="line">	   quantity,</span><br><span class="line">	   item_price,</span><br><span class="line">	   quantity*item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">from</span> orderitems</span><br><span class="line"><span class="keyword">where</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用数据处理函数"><a class="header-anchor" href="#使用数据处理函数"></a>使用数据处理函数</h3>
<h4 id="文本处理函数"><a class="header-anchor" href="#文本处理函数"></a>文本处理函数</h4>
<ol>
<li>Trim()</li>
<li>Upper()</li>
<li>Lower()</li>
<li>Soundex()：返回串的soundex值，能对串进行发音比较</li>
<li>……</li>
</ol>
<h4 id="日期和时间处理函数"><a class="header-anchor" href="#日期和时间处理函数"></a>日期和时间处理函数</h4>
<p>日期格式必须为yyyy-mm-dd</p>
<p>MySQL中存在类型datetime，格式为：yyyy-MM-dd HH:mm:ss</p>
<p>如果要的只是日期，需要使用Date()函数，也存在一个Time()函数</p>
<h4 id="数值处理函数"><a class="header-anchor" href="#数值处理函数"></a>数值处理函数</h4>
<ol>
<li>Abs()</li>
<li>Cos()</li>
<li>Exp()</li>
<li>Mod()</li>
<li>……</li>
</ol>
<h3 id="汇总数据"><a class="header-anchor" href="#汇总数据"></a>汇总数据</h3>
<h4 id="聚集函数"><a class="header-anchor" href="#聚集函数"></a>聚集函数</h4>
<blockquote>
<p>运行在行组上，计算和返回单个值的函数</p>
</blockquote>
<h5 id="avg"><a class="header-anchor" href="#avg"></a>AVG()</h5>
<blockquote>
<p>返回某列的平均值</p>
</blockquote>
<p>忽略列值为null的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>
<h5 id="count"><a class="header-anchor" href="#count"></a>COUNT()</h5>
<blockquote>
<p>返回某列的行数</p>
</blockquote>
<p>如果指定列名，值为null的行将被忽略。如果使用COUNT(*)，则不忽略</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_cust <span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure>
<h5 id="max"><a class="header-anchor" href="#max"></a>MAX()</h5>
<blockquote>
<p>返回某列的最大值，忽略值为null的行</p>
</blockquote>
<p>一般用于数值或日期值。在用于文本数据时，如果数据按相应列排序，则MAX()返回最后一行</p>
<h5 id="mix"><a class="header-anchor" href="#mix"></a>MIX()</h5>
<blockquote>
<p>返回某列的最小值,与MAX相反</p>
</blockquote>
<h5 id="sun"><a class="header-anchor" href="#sun"></a>SUN()</h5>
<blockquote>
<p>返回某列值值和</p>
</blockquote>
<h4 id="聚集不同值"><a class="header-anchor" href="#聚集不同值"></a>聚集不同值</h4>
<p>ALL为默认，对所有的行执行操作</p>
<p>DISTINCT，只包含不同的值</p>
<h4 id="组合聚集函数"><a class="header-anchor" href="#组合聚集函数"></a>组合聚集函数</h4>
<p>可以同时使用多个聚集函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_item,</span><br><span class="line">	   <span class="keyword">MIN</span>(prod_price) <span class="keyword">AS</span> price_min,</span><br><span class="line">	   <span class="keyword">MAX</span>(prod_price) <span class="keyword">AS</span> price_max,</span><br><span class="line">	   <span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> price_avg</span><br><span class="line"><span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure>
<h5 id="取别名"><a class="header-anchor" href="#取别名"></a>取别名</h5>
<blockquote>
<p>不应该使用表中实际的列名。并非不合法，但是使用唯一的名字会使SQL更易于理解</p>
</blockquote>
<h3 id="分组数据"><a class="header-anchor" href="#分组数据"></a>分组数据</h3>
<h4 id="group-by子句"><a class="header-anchor" href="#group-by子句"></a>GROUP BY子句</h4>
<blockquote>
<p>group by子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods <span class="keyword">FROM</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id;</span><br></pre></td></tr></table></figure>
<p>重要规定</p>
<ul>
<li>group by子句可以包含任意数目的列</li>
<li>如果在group by子句中嵌套了分组，数据将在最后规定的分组上进行汇总</li>
<li>group by子句中列出的每个列都必须是检索列或有效的表达式（但是不能是聚集函数）</li>
<li>除聚集计算语句外，select语句中的每个列都必须在group by子句中给出</li>
<li>如果分组列中具有null值，则null将作为一个分组返回</li>
<li>group by子句必须出现在where子句之后，order by子句之前</li>
</ul>
<p><strong>使用ROLLUP</strong>：使用关键字with rollup可以得到每个分组以及每个分组汇总级别的值</p>
<h4 id="过滤分组"><a class="header-anchor" href="#过滤分组"></a>过滤分组</h4>
<p>where过滤指定的是行而不是分组</p>
<p>可以使用having子句过滤分组，having支持所有where操作符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> orders <span class="keyword">FROM</span> orders <span class="keyword">group</span> <span class="keyword">by</span> cust_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h4 id="分组和排序"><a class="header-anchor" href="#分组和排序"></a>分组和排序</h4>
<p><strong>一般在使用group by子句时，应该也给出order by子句</strong></p>
<h4 id="select子句顺序"><a class="header-anchor" href="#select子句顺序"></a>select子句顺序</h4>
<p>select→from→where→group by→having→order by→limit</p>
<h3 id="使用子查询"><a class="header-anchor" href="#使用子查询"></a>使用子查询</h3>
<blockquote>
<p>子查询：嵌套在其他查询里的查询</p>
</blockquote>
<p>子查询总是从内向外处理</p>
<p>一般与IN操作符结合使用</p>
<p>以下两条语句可合并为一条</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">from</span> orderitems <span class="keyword">where</span> prod_id = <span class="string">'TNT2'</span>; <span class="comment">-- 查询结果为 20005 20007</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id <span class="keyword">from</span> orders <span class="keyword">where</span> order_num <span class="keyword">IN</span>(<span class="number">20005</span>,<span class="number">20007</span>);  <span class="comment">-- 查询结果为10001 10004</span></span><br></pre></td></tr></table></figure>
<p>使用子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id </span><br><span class="line"><span class="keyword">from</span> orders </span><br><span class="line"><span class="keyword">where</span> order_num <span class="keyword">IN</span>(<span class="keyword">SELECT</span> order_num </span><br><span class="line">                   <span class="keyword">from</span> orderitems </span><br><span class="line">                   <span class="keyword">where</span> prod_id = <span class="string">'TNT2'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="连结表"><a class="header-anchor" href="#连结表"></a>连结表</h3>
<blockquote>
<p>联结是利用SQL的select能执行的最重要的操作</p>
</blockquote>
<p>主键</p>
<p>外键</p>
<p>涉及两个表的查询，在引用的列可能出现二义性时，必须使用完全限定列名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">from</span> vendors, products</span><br><span class="line"><span class="keyword">where</span> venders.vend_id = products.vend_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure>
<p>如果不使用where子句建立联结条件，那么返回的结果为笛卡尔积。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">from</span> vendors, products</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure>
<p>==应该保证所有的联结都有where子句==</p>
<h4 id="内部联结"><a class="header-anchor" href="#内部联结"></a>内部联结</h4>
<blockquote>
<p>内部联结，也称为等值联结，基于两表之间的相等测试</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">from</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> venders.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<p>使用<code>INNER JOIN</code>之后，用<code>ON</code>子句指定联结条件</p>
<h4 id="联结多个表"><a class="header-anchor" href="#联结多个表"></a>联结多个表</h4>
<p>联结的表越多，性能下降的越厉害</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price, quantity</span><br><span class="line"><span class="keyword">from</span> vendors, products,orderitems</span><br><span class="line"><span class="keyword">where</span> venders.vend_id = products.vend_id</span><br><span class="line">  <span class="keyword">AND</span> orderitems.prod_id = products.prod_id</span><br><span class="line">  <span class="keyword">AND</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
<h3 id="创建高级联结"><a class="header-anchor" href="#创建高级联结"></a>创建高级联结</h3>
<h4 id="使用表别名"><a class="header-anchor" href="#使用表别名"></a>使用表别名</h4>
<ul>
<li>缩短SQL语句</li>
<li>允许单条SELECT语句中多次使用相同表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id</span><br><span class="line">  <span class="keyword">AND</span> oi.order_num = o.order_num</span><br><span class="line">  <span class="keyword">AND</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用不同类型的联结"><a class="header-anchor" href="#使用不同类型的联结"></a>使用不同类型的联结</h4>
<h5 id="自联结"><a class="header-anchor" href="#自联结"></a>自联结</h5>
<p>假如发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否存在问题。</p>
<p>使用子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = (<span class="keyword">SELECT</span> vend_id</span><br><span class="line">				 <span class="keyword">FROM</span> products</span><br><span class="line">				 <span class="keyword">WHERE</span> prod_id = <span class="string">'DTNTR'</span>);</span><br></pre></td></tr></table></figure>
<p>使用联结的相同查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.vend_id = p2.vend_id</span><br><span class="line">  <span class="keyword">AND</span> p2.prod_id = <span class="string">'DTNTR'</span>;</span><br></pre></td></tr></table></figure>
<p>此查询中需要的两个表实际上是相同的表，通过使用别名避免二义性。</p>
<p>使用自联结比子查询效率更高。</p>
<h5 id="自然联结"><a class="header-anchor" href="#自然联结"></a>自然联结</h5>
<blockquote>
<p>对表进行联结，应该至少有一个列出现在不止一个表中，标准的联结返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次</p>
</blockquote>
<p>一般通过对表使用通配符(SELECT *)，对其他表的列使用明确的子集来完成。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitem <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id</span><br><span class="line">  <span class="keyword">AND</span> oi.order_num = o.order_num</span><br><span class="line">  <span class="keyword">AND</span> prod_id = <span class="string">'FB'</span>;</span><br></pre></td></tr></table></figure>
<p>通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。</p>
<h5 id="外部联结"><a class="header-anchor" href="#外部联结"></a>外部联结</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, order.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>使用了<code>OUTER JOIN</code>来指定联结的类型。与内部联结不同的是外部联结还包括没有关联的行。</p>
<p>使用LEFT或RIGHT关键词指定包括其所有行的表</p>
<p>上面例子中使用LEFT OUTER JOIN 从customers表中选择所有行，即左（外）连接</p>
<p>下面展示右（外）连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, order.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<h4 id="使用带聚集函数的联结"><a class="header-anchor" href="#使用带聚集函数的联结"></a>使用带聚集函数的联结</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_name,</span><br><span class="line">	   customers.cust_id,</span><br><span class="line">	   <span class="keyword">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>
<h4 id="使用联结和联结条件"><a class="header-anchor" href="#使用联结和联结条件"></a>使用联结和联结条件</h4>
<ul>
<li>注意使用的联结类型</li>
<li>保证使用正确的联结条件</li>
<li>应该总是提供联结条件，否则会得出笛卡尔积</li>
<li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型</li>
</ul>
<h3 id="组合查询"><a class="header-anchor" href="#组合查询"></a>组合查询</h3>
<p>有两种基本情况，其中需要使用组合查询：</p>
<ul>
<li>在单个查询中从不同的表返回类似结构的数据</li>
<li>对单个表执行多个查询，按单个查询返回数据</li>
</ul>
<h4 id="创建组合查询"><a class="header-anchor" href="#创建组合查询"></a>创建组合查询</h4>
<h5 id="union操作符"><a class="header-anchor" href="#union操作符"></a>UNION操作符</h5>
<p>以下两条SELECT语句可使用UNION组合</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<p>组合</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span>;</span><br><span class="line">UNION</span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<p>给出使用多条WHERE子句而不是使用UNION的相同查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line">	<span class="keyword">OR</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<p>这里使用UNION可能比使用WHERE子句更复杂，但是对于更复杂的过滤条件，或者从多个表中检索数据的情形，使用UNION可能会使处理更简单</p>
<h5 id="union规则"><a class="header-anchor" href="#union规则"></a>UNION规则</h5>
<ul>
<li>必须由两条或以上SELECT语句组成</li>
<li>每个查询必须包含相同的列，表达式或聚集函数（次序可不同）</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型</li>
</ul>
<h5 id="包含或取消重复的行"><a class="header-anchor" href="#包含或取消重复的行"></a>包含或取消重复的行</h5>
<p>UNION从查询结果集中自动去除了重复的行</p>
<p>如果想匹配所有行，可使用<code>UNION ALL</code>而不是<code>UNION</code></p>
<h5 id="对组合查询结果排序"><a class="header-anchor" href="#对组合查询结果排序"></a>对组合查询结果排序</h5>
<p>SELECT语句的输出用ORDER BY子句排序。</p>
<p>在用UNION组合查询时，只能用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后</p>
<h3 id="全文本搜索"><a class="header-anchor" href="#全文本搜索"></a>全文本搜索</h3>
<p><strong>并非所有引擎都支持全文本搜索</strong></p>
<p>MyISAM支持，InnoDB不支持</p>
<h4 id="使用全文本搜索"><a class="header-anchor" href="#使用全文本搜索"></a>使用全文本搜索</h4>
<blockquote>
<p>为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引</p>
</blockquote>
<p>在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引</p>
<h4 id="启用全文本搜索支持"><a class="header-anchor" href="#启用全文本搜索支持"></a>启用全文本搜索支持</h4>
<p>一般在创建表时启用全文本搜索。<code>CREATE TABLE</code>语句接收FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">  note_id    <span class="built_in">int</span>           <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  prod_id    <span class="built_in">char</span>(<span class="number">10</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  note_date datetime       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  note_text  <span class="built_in">text</span>          <span class="literal">NULL</span> ,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(note_id),</span><br><span class="line">  FULLTEXT(note_text)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure>
<p>有一个名为<code>note_text</code>的列，为了进行全文本搜索，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。</p>
<h4 id="进行全文本搜索"><a class="header-anchor" href="#进行全文本搜索"></a>进行全文本搜索</h4>
<p>使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'rabbit'</span>);</span><br></pre></td></tr></table></figure>
<p>此select语句检索单个列note_text，由于WHERE子句，一个全文本搜索被执行。Match(note_text)指示MySQL针对的列进行搜索，Against(‘rabbit’)指定词rabbit作为搜索文本。</p>
<p>Match()说明：传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</p>
<p>搜索不区分大小写：除非使用BINARY方式。</p>
<p>事实上，刚才的搜索可以简单的用like子句替换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> note_text <span class="keyword">LIKE</span> <span class="string">'%rabbit%'</span>;</span><br></pre></td></tr></table></figure>
<p>LIKE以不特别有用的顺序返回数据。</p>
<p>全文本搜索返回以文本匹配的良好程度排序的数据。</p>
<h4 id="使用查询扩展"><a class="header-anchor" href="#使用查询扩展"></a>使用查询扩展</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'anvils'</span> <span class="keyword">WITH</span> EXPANSION);</span><br></pre></td></tr></table></figure>
<p>行越多使用扩展查询返回的结果越好</p>
<h4 id="布尔文本搜索"><a class="header-anchor" href="#布尔文本搜索"></a>布尔文本搜索</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'heavy'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<h4 id="全文本搜索的使用说明"><a class="header-anchor" href="#全文本搜索的使用说明"></a>全文本搜索的使用说明</h4>
<ul>
<li>在索引全文本数据时，短词被忽略且从索引中排除</li>
<li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略</li>
<li>许多次出现的频率很高，搜索它们没有用处。MySQL制定了一条50%规则</li>
<li>如果表中的行数少于3行，则全文本搜索不返回结果</li>
<li>忽略词中的单引号</li>
<li>不具有词分隔符的语言不能恰当地返回全文本搜索结果</li>
<li>仅在MyISAM数据库索引中支持全文本搜索</li>
</ul>
<h3 id="插入数据"><a class="header-anchor" href="#插入数据"></a>插入数据</h3>
<h4 id="插入完整的行"><a class="header-anchor" href="#插入完整的行"></a>插入完整的行</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="string">'Pep E. LaPew'</span>, <span class="string">'100 Main Street'</span>, <span class="string">'Los Angeles'</span>, <span class="string">'CA'</span>, <span class="string">'90046'</span>, <span class="string">'USA'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>更安全的方式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_name, cust_contact, cust_email, cust_address, cust_city, cust_state, cust_zip, cust_conutry) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'Pep E. LaPew'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">'100 Main Street'</span>, <span class="string">'Los Angeles'</span>, <span class="string">'CA'</span>, <span class="string">'90046'</span>, <span class="string">'USA'</span>);</span><br></pre></td></tr></table></figure>
<p>必须给出VALUES的正确数目。如果不提供列名，则必须给每个列提供一个值。如果提供列名，则必须对每个列出的列给出一个值。</p>
<p><strong>省略列</strong></p>
<ul>
<li>该列定义为允许NULL值</li>
<li>在表定义中给出默认值</li>
</ul>
<h4 id="插入多行"><a class="header-anchor" href="#插入多行"></a>插入多行</h4>
<p>多条INSERT语句</p>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(……) <span class="keyword">VALUES</span>(……),(……);</span><br></pre></td></tr></table></figure>
<h4 id="插入某些查询的结果"><a class="header-anchor" href="#插入某些查询的结果"></a>插入某些查询的结果</h4>
<p><code>INSERT SELECT</code></p>
<h3 id="更新和删除数据"><a class="header-anchor" href="#更新和删除数据"></a>更新和删除数据</h3>
<h4 id="更新数据"><a class="header-anchor" href="#更新数据"></a>更新数据</h4>
<ul>
<li>更新特定行</li>
<li>更新所有行</li>
</ul>
<p><strong>不要省略WHERE子句</strong></p>
<p>UPDATE语句三部分</p>
<ol>
<li>要更新的表</li>
<li>列名和它们的新值</li>
<li>确定要更新行的过滤条件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers <span class="keyword">SET</span> cust_email = <span class="string">'elmer@fudd.com'</span> <span class="keyword">WHERE</span> cust_id = <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>
<p>如果用UPDATE更新多行，更新时可能会出现错误，那么则整个更新操作都会被取消。</p>
<p>如果想即使发生错误也要继续更新，可以使用<code>IGNORE</code>关键字，示例<code>UPDATE IGNORE customers...</code></p>
<h4 id="删除数据"><a class="header-anchor" href="#删除数据"></a>删除数据</h4>
<ul>
<li>删除特定行</li>
<li>删除所有行</li>
</ul>
<p><strong>不要省略WHERE子句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_id = <span class="number">10006</span>;</span><br></pre></td></tr></table></figure>
<p><strong>删除所有行</strong>：使用<code>TRUNCATE TABLE</code> truncate实际是删除原来的表并重新创建一个表，而不是逐行删除数据</p>
<h3 id="创建和操纵表"><a class="header-anchor" href="#创建和操纵表"></a>创建和操纵表</h3>
<h4 id="创建表"><a class="header-anchor" href="#创建表"></a>创建表</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customers(</span><br><span class="line">    cust_id		 	<span class="built_in">int</span>			<span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    cust_name	 	<span class="built_in">char</span>(<span class="number">50</span>)	<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    cust_address	<span class="built_in">char</span>(<span class="number">50</span>)	<span class="literal">NULL</span>,</span><br><span class="line">    cust_city		<span class="built_in">char</span>(<span class="number">50</span>)	<span class="literal">NULL</span>,</span><br><span class="line">    cust_state		<span class="built_in">char</span>(<span class="number">5</span>)		<span class="literal">NULL</span>,</span><br><span class="line">    cust_zip		<span class="built_in">char</span>(<span class="number">10</span>)	<span class="literal">NULL</span>,</span><br><span class="line">    cust_country	<span class="built_in">char</span>(<span class="number">50</span>)	<span class="literal">NULL</span>,</span><br><span class="line">    cust_contact	<span class="built_in">char</span>(<span class="number">50</span>)	<span class="literal">NULL</span>,</span><br><span class="line">    cust_email		<span class="built_in">char</span>(<span class="number">255</span>)	<span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>	(cust_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>确定AUTO_INCREMENT的值</p>
<p>使用 SELECT last_insert_id()函数，返回最后一个AUTO_INCREMENT值</p>
<h4 id="引擎类型"><a class="header-anchor" href="#引擎类型"></a>引擎类型</h4>
<ul>
<li>InnoDB：可靠的事务处理引擎，不支持全文本搜索</li>
<li>MEMORY：功能等同于MyISAM，但用于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）</li>
<li>MyISAM：性能极高的引擎，支持全文本搜索，但不支持事务处理</li>
</ul>
<p>外键不能跨引擎</p>
<h4 id="更新表"><a class="header-anchor" href="#更新表"></a>更新表</h4>
<p><code>ALTER TABLE</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> venders <span class="keyword">ADD</span> vend_phone <span class="built_in">CHAR</span>(<span class="number">20</span>);	<span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> venders <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;		<span class="comment">-- 删除列</span></span><br></pre></td></tr></table></figure>
<p>常见用途：定义外键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_orders</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (order_num) <span class="keyword">REFERENCES</span> orders (order_num);</span><br></pre></td></tr></table></figure>
<h4 id="删除表"><a class="header-anchor" href="#删除表"></a>删除表</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers2;</span><br></pre></td></tr></table></figure>
<h4 id="重命名表"><a class="header-anchor" href="#重命名表"></a>重命名表</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> customers2 <span class="keyword">TO</span> customers;</span><br></pre></td></tr></table></figure>
<h3 id="使用视图"><a class="header-anchor" href="#使用视图"></a>使用视图</h3>
<h3 id="使用存储过程"><a class="header-anchor" href="#使用存储过程"></a>使用存储过程</h3>
<h3 id="使用游标"><a class="header-anchor" href="#使用游标"></a>使用游标</h3>
<h3 id="使用触发器"><a class="header-anchor" href="#使用触发器"></a>使用触发器</h3>
<h3 id="管理事务处理"><a class="header-anchor" href="#管理事务处理"></a>⭐️管理事务处理</h3>
<h4 id="事务处理"><a class="header-anchor" href="#事务处理"></a>事务处理</h4>
<p><strong>并非所有引擎都支持事务处理</strong>：InnoDB支持，MyISAM不支持</p>
<blockquote>
<p>维护数据库的完整性，保证成批的MySQL操作要么完全执行，要么完全不执行</p>
</blockquote>
<p>几个术语：</p>
<ul>
<li>事务（transaction）：指一组SQL语句</li>
<li>回退（rollback）：指撤销指定SQL语句的过程</li>
<li>提交（commit）：指将未存储的SQL语句写入数据库表</li>
<li>保留点（savepoint）：指事务发布中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务不同）</li>
</ul>
<h4 id="控制事务处理"><a class="header-anchor" href="#控制事务处理"></a>控制事务处理</h4>
<h5 id="使用rollback"><a class="header-anchor" href="#使用rollback"></a>使用ROLLBACK</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>	<span class="comment">-- 标识事务开始</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;			<span class="comment">-- 回滚</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br></pre></td></tr></table></figure>
<p>事务处理用来管理<code>INSERT、UPDATE、DELETE</code>语句。不能回退<code>SELECT</code>语句（没意义），不能回退<code>CREATE、DROP</code>操作，事务管理中可以使用这两条语句，但是执行回退并不会被撤销。</p>
<h5 id="使用commit"><a class="header-anchor" href="#使用commit"></a>使用COMMIT</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>	<span class="comment">-- 标识事务开始</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;			<span class="comment">-- 提交</span></span><br></pre></td></tr></table></figure>
<p>当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）</p>
<h5 id="使用保留点"><a class="header-anchor" href="#使用保留点"></a>使用保留点</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> delete1;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1;</span><br></pre></td></tr></table></figure>
<p>保留点越多越好</p>
<p>保留点在事务处理完成后（执行一条）自动释放，MySQL 5以来，也可以使用RELEASE SAVEPOINT明确地释放保留点。</p>
<h4 id="更改默认的提交行为"><a class="header-anchor" href="#更改默认的提交行为"></a>更改默认的提交行为</h4>
<p>默认MySQL行为是自动提交所有更改。为指示MySQL不自动提交更改，需要使用以下语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>autocommit标志决定是否自动提交更改，不管有没有commit语句。设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）</p>
<p><strong>autocommit标志是针对每个连接而不是服务器的</strong></p>
<h3 id="全球化和本地化"><a class="header-anchor" href="#全球化和本地化"></a>全球化和本地化</h3>
<h4 id="使用字符集和校对顺序"><a class="header-anchor" href="#使用字符集和校对顺序"></a>使用字符集和校对顺序</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="built_in">character</span> <span class="keyword">set</span>;		<span class="comment">-- 显示所有可用的字符集以及每个字符集的描述和默认校对</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">collation</span>;			<span class="comment">-- 显示所有可用的校对，以及它们适用的字符集</span></span><br></pre></td></tr></table></figure>
<h3 id="安全控制"><a class="header-anchor" href="#安全控制"></a>安全控制</h3>
<h4 id="管理用户"><a class="header-anchor" href="#管理用户"></a>管理用户</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<h5 id="创建用户账号"><a class="header-anchor" href="#创建用户账号"></a>创建用户账号</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">USER</span> ben <span class="keyword">IDENTIFIED</span> <span class="keyword">by</span> <span class="string">'p@$$w0rd'</span>;</span><br></pre></td></tr></table></figure>
<p>重命名用户账号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> ben <span class="keyword">TO</span> bforta;</span><br></pre></td></tr></table></figure>
<h5 id="删除用户账户"><a class="header-anchor" href="#删除用户账户"></a>删除用户账户</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> bforta;</span><br></pre></td></tr></table></figure>
<h5 id="设置访问权限"><a class="header-anchor" href="#设置访问权限"></a>设置访问权限</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> bforta;		<span class="comment">-- 查看赋予用户的权限</span></span><br><span class="line"><span class="comment">-- 显示有一个权限USAGE ON *.* USAGE表示根本没有权限</span></span><br></pre></td></tr></table></figure>
<p>设置权限，使用GRANT语句。至少要使用以下信息：</p>
<ul>
<li>要授予的权限</li>
<li>被授予访问权限的数据库或表</li>
<li>用户名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">TO</span> bforta;	<span class="comment">-- 允许bforta用户在crashcourse.*上使用select</span></span><br></pre></td></tr></table></figure>
<p>反操作<code>REVOKE</code>撤销权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">TO</span> bforta;	<span class="comment">-- 撤销bforta用户在crashcourse.*上使用select权限</span></span><br></pre></td></tr></table></figure>
<p>几个层次上的控制访问权限</p>
<ul>
<li>整个服务器：GRANT ALL和REVOKE ALL</li>
<li>整个数据库：使用ON database.*</li>
<li>特定的表：使用ON database.table</li>
<li>特定的列</li>
<li>特定的存储过程</li>
</ul>
<h5 id="更改口令"><a class="header-anchor" href="#更改口令"></a>更改口令</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> bforta = <span class="keyword">Password</span>(<span class="string">'n3w p@$$w0rd'</span>);</span><br></pre></td></tr></table></figure>
<p>不指定用户名则更新当前登录用户的口令</p>
<h3 id="数据库维护"><a class="header-anchor" href="#数据库维护"></a>数据库维护</h3>
<h4 id="备份数据"><a class="header-anchor" href="#备份数据"></a>备份数据</h4>
<h4 id="进行数据库维护"><a class="header-anchor" href="#进行数据库维护"></a>进行数据库维护</h4>
<h4 id="诊断启动问题"><a class="header-anchor" href="#诊断启动问题"></a>诊断启动问题</h4>
<h4 id="查看日志文件"><a class="header-anchor" href="#查看日志文件"></a>查看日志文件</h4>
<h3 id="改善性能"><a class="header-anchor" href="#改善性能"></a>改善性能</h3>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次大坑———maven与Java版本的问题</title>
    <url>/2020/06/23/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%A7%E5%9D%91%E2%80%94%E2%80%94%E2%80%94maven%E4%B8%8EJava%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题复现"><a class="header-anchor" href="#问题复现"></a>问题复现</h2>
<p>首先新建一个maven项目</p>
<p>在pom.xml中随意导入一个依赖</p>
<p>这里我在阿里云maven仓库中随便找了一个</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/jaicore.png" alt="alimaven"></p>
<p>在项目中导入依赖后报错</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/20200623141012.png" alt="wrong"></p>
<a id="more"></a>
<p>详细报错信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could not transfer artifact ai.libs:jaicore-planning:pom:0.1.4 from&#x2F;to alimaven (http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;): Transfer failed for http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;ai&#x2F;libs&#x2F;jaicore-planning&#x2F;0.1.4&#x2F;jaicore-planning-0.1.4.pom</span><br></pre></td></tr></table></figure>
<p>发现在本地maven仓库中只下载了.lastupdated文件</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/20200623141629.png" alt=""></p>
<h2 id="尝试解决方法1"><a class="header-anchor" href="#尝试解决方法1"></a>尝试解决方法1</h2>
<p>查看其他人的解决办法，需要删除此文件重新导入</p>
<p>这里附上删除所有.lastupdated文件脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#清理maven仓库.bat</span></span><br><span class="line"><span class="built_in">set</span> REPOSITORY_PATH=D:\maven\repository <span class="comment">#此处修改为本地maven仓库的路径</span></span><br><span class="line">rem 正在搜索...</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">"delims="</span> %%i <span class="keyword">in</span> (<span class="string">'dir /b /s "%REPOSITORY_PATH%\*lastUpdated*"'</span>) <span class="keyword">do</span> (</span><br><span class="line">    del /s /q %%i</span><br><span class="line">)</span><br><span class="line">rem 搜索完毕</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>然后这并没有解决我的问题，无论删除多少次，再重新导入依赖，都只会生成.lastupdated文件！！心累😫</p>
<p>显然，这个方法不能解决问题。</p>
<h2 id="尝试解决方法2"><a class="header-anchor" href="#尝试解决方法2"></a>尝试解决方法2</h2>
<p>然后我也曾想是不是阿里云镜像仓库的问题，可能阿里云仓库中没有这个jar包？换个镜像能不能解决问题。现在看来也显然不是，因为我这里就是之间在阿里云仓库中找的依赖。😢</p>
<h2 id="尝试解决方法3"><a class="header-anchor" href="#尝试解决方法3"></a>尝试解决方法3</h2>
<p>在terminal中使用<code>mvn install -e</code>命令查看报错信息</p>
<p>找到关键信息</p>
<p>？？？</p>
<p>错误复现的时候，他突然build success？？？</p>
<p>我无语</p>
<p>本来应该是这个错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed Error</span><br></pre></td></tr></table></figure>
<p>按照网上方法添加证书的</p>
<p>从网站上下载证书保存为xxx.cer</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> %JAVA_HOME%\lib\security\cacerts</span><br><span class="line">keytool -import -<span class="built_in">alias</span> xxx -keystore cacerts -file D://xxx.cer</span><br><span class="line">keytool -list -keystore cacerts -<span class="built_in">alias</span> &lt;<span class="built_in">alias</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="解法方法4"><a class="header-anchor" href="#解法方法4"></a>解法方法4</h2>
<p>本来的解决方案是maven3.6.3需要更换Java版本，我用的openjdk14成功了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-14<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span>    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>14<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>14<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span>    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>14<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span>    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>14<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者使用旧版本maven 3.6.1可使用Java1.8</p>
<p>写博客搞着搞着maven3.6.3又用不了了，openjdk14也不行了，换回了3.6.1</p>
<p>就很看缘分？？</p>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<blockquote>
<p>主要原因还是版本的问题吧</p>
</blockquote>
<p>我改回maven3.6.1之后就没问题了</p>
]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>字节跳动后端开发笔试20200511</title>
    <url>/2020/05/11/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%9520200511/</url>
    <content><![CDATA[<h2 id="简易文本编辑器"><a class="header-anchor" href="#简易文本编辑器"></a>简易文本编辑器</h2>
<h3 id="题目描述"><a class="header-anchor" href="#题目描述"></a>题目描述</h3>
<blockquote>
<p>输入：<br>
第一行 正整数N表示N个命令<br>
接下来每一行表示一个命令<br>
1 xx 追加xx到内容后面<br>
2 k  删除最后k个字符<br>
3 k  输出S的第k个字符<br>
4 回滚上一步对S的操作，只有1和2</p>
</blockquote>
<h3 id="示例输入"><a class="header-anchor" href="#示例输入"></a>示例输入</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">1 abc</span><br><span class="line">3 3</span><br><span class="line">2 3</span><br><span class="line">1 xy</span><br><span class="line">3 2</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">3 1</span><br></pre></td></tr></table></figure>
<h3 id="实例输出"><a class="header-anchor" href="#实例输出"></a>实例输出</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line">y</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="笔试时写出的代码-ac"><a class="header-anchor" href="#笔试时写出的代码-ac"></a>笔试时写出的代码，ac</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stack;<span class="comment">//保存操作，方便回滚（只保存1，2）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] command;<span class="comment">//命令数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] val;<span class="comment">//命令对应的值的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StringBuilder str;<span class="comment">//文本框中的内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;String&gt; del;<span class="comment">//删除操作删除的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> N = s.nextInt();</span><br><span class="line">        command = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        val = <span class="keyword">new</span> String[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            command[i] = s.nextInt();</span><br><span class="line">            val[i] = s.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去除输入的空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!val[i].equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                StringBuilder ss = <span class="keyword">new</span> StringBuilder(val[i]);</span><br><span class="line">                ss.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">                val[i] = String.valueOf(ss);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        del = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历命令字符串数组，依次执行命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//命令1，追加字符串</span></span><br><span class="line">            <span class="keyword">if</span> (command[i] == <span class="number">1</span>) str.append(val[i]);</span><br><span class="line">            <span class="comment">//命令2，删除字符串</span></span><br><span class="line">            <span class="keyword">if</span> (command[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//将删除的字符串存入del栈中，方便回滚</span></span><br><span class="line">                <span class="keyword">if</span> (Integer.parseInt(val[i]) &gt;= str.length()) del.push(String.valueOf(str));</span><br><span class="line">                <span class="keyword">else</span> del.push(str.substring(str.length() - Integer.parseInt(val[i]), str.length()));</span><br><span class="line">                <span class="comment">//删除字符串</span></span><br><span class="line">                <span class="keyword">if</span> (Integer.parseInt(val[i]) &gt;= str.length()) str.delete(<span class="number">0</span>, str.length());</span><br><span class="line">                <span class="keyword">else</span> str.delete(str.length() - Integer.parseInt(val[i]), str.length());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//命令3，输出字符</span></span><br><span class="line">            <span class="keyword">if</span> (command[i] == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = Integer.parseInt(String.valueOf(val[i])) - <span class="number">1</span>;</span><br><span class="line">                System.out.println(str.charAt(index));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//命令4，回滚</span></span><br><span class="line">            <span class="keyword">if</span> (command[i] == <span class="number">4</span>) rollback();</span><br><span class="line">            <span class="comment">//命令1，2依次入栈，存储的是数组的索引</span></span><br><span class="line">            <span class="keyword">if</span> (command[i] != <span class="number">4</span> &amp;&amp; command[i] != <span class="number">3</span>) stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回滚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = stack.pop();<span class="comment">//获取栈顶元素，即上一次执行的操作的数组索引</span></span><br><span class="line">        <span class="keyword">int</span> cmd = command[index];<span class="comment">//根据索引获取命令</span></span><br><span class="line">        String value = val[index];<span class="comment">//根据索引获取命令对应的值</span></span><br><span class="line">        <span class="comment">//上次命令为1，追加字符串，回滚则删除追加的字符串</span></span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = value.length();</span><br><span class="line">            str.delete(str.length() - len, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上次命令为2，删除字符串，回滚则追加删除的字符串</span></span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="number">2</span>) str.append(del.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文章翻译"><a class="header-anchor" href="#文章翻译"></a>文章翻译</h2>
<h3 id="题目描述-v2"><a class="header-anchor" href="#题目描述-v2"></a>题目描述</h3>
<blockquote>
<p>输入：<br>
第一行表示文章，长度不超过50000<br>
第二行，正整数[2,50000]，字典单词<br>
N行，每行一个单词<br>
输出:<br>
文章翻译种数对835672545取余<br>
无法翻译输出0</p>
</blockquote>
<h3 id="示例输入-v2"><a class="header-anchor" href="#示例输入-v2"></a>示例输入</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcba</span><br><span class="line">5</span><br><span class="line">ab</span><br><span class="line">cb</span><br><span class="line">bc</span><br><span class="line">ba</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<h3 id="示例输出"><a class="header-anchor" href="#示例输出"></a>示例输出</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="袜子染色"><a class="header-anchor" href="#袜子染色"></a>袜子染色</h2>
<h3 id="题目描述-v3"><a class="header-anchor" href="#题目描述-v3"></a>题目描述</h3>
<blockquote>
<p>第i天穿袜子a_i和b_i，要求颜色标号相同<br>
第一行两个整数n（袜子数量）和m（天数）均小于100,000<br>
第二行n个整数，第i个数c_i表示第i只袜子颜色，不大于100,000<br>
接下来m行，每行两个整数a_i和b_i，表示第i天穿的袜子编号<br>
输出最少需要染色数</p>
</blockquote>
<h3 id="示例输入-v3"><a class="header-anchor" href="#示例输入-v3"></a>示例输入</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="示例输出-v2"><a class="header-anchor" href="#示例输出-v2"></a>示例输出</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="和猫咪玩游戏"><a class="header-anchor" href="#和猫咪玩游戏"></a>和猫咪玩游戏</h2>
<h3 id="题目描述-v4"><a class="header-anchor" href="#题目描述-v4"></a>题目描述</h3>
<blockquote>
<p>首先输入字符串s<br>
一行输入一个n，表示接下来有n个操作<br>
接下来n行，每行表示一个操作<br>
修改：1 整数pos 一个字符c 表示将整数替换为c<br>
提问：2 l r  求s[l…r]有多少个互不相同的字符</p>
</blockquote>
<h3 id="示例输入-v4"><a class="header-anchor" href="#示例输入-v4"></a>示例输入</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abacaba</span><br><span class="line">5</span><br><span class="line">2 1 4</span><br><span class="line">1 4 b</span><br><span class="line">1 5 b</span><br><span class="line">2 4 6</span><br><span class="line">2 1 7</span><br></pre></td></tr></table></figure>
<h3 id="示例输出-v3"><a class="header-anchor" href="#示例输出-v3"></a>示例输出</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2>
<p>㊗️恭喜你看完了这篇文章！</p>
<p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p>
<p>📧 <a href="mailto:yll1671158@163.com">我的邮箱</a></p>
]]></content>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/04/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程的生命周期"><a class="header-anchor" href="#线程的生命周期"></a>线程的生命周期</h2>
<h3 id="新建状态"><a class="header-anchor" href="#新建状态"></a>新建状态</h3>
<p>使用new关键词创建一个线程后，处于新建状态，仅由JVM为其分配内存，并初始化其成员变量</p>
<h3 id="就绪状态"><a class="header-anchor" href="#就绪状态"></a>就绪状态</h3>
<p>线程对象调用了start()方法之后。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行</p>
<h3 id="运行状态"><a class="header-anchor" href="#运行状态"></a>运行状态</h3>
<p>就绪状态的线程获得了cpu，开始执行run()方法的线程执行体</p>
<h3 id="阻塞状态"><a class="header-anchor" href="#阻塞状态"></a>阻塞状态</h3>
<p>由于某种原因放弃了cpu使用权</p>
<p>分三种情况</p>
<ul>
<li>等待阻塞：执行wait()方法，进入等待队列</li>
<li>同步阻塞：获取对象同步锁时，同步锁被其他线程占用，JVM会把该线程放入锁池中</li>
<li>其他阻塞：执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求</li>
</ul>
<h3 id="线程死亡"><a class="header-anchor" href="#线程死亡"></a>线程死亡</h3>
<p>线程会以三种方式结束，结束后就是死亡状态</p>
<ul>
<li>
<p>正常结束：run()或call()方法执行完成</p>
</li>
<li>
<p>异常结束：线程抛出一个未捕获的Exception或Error</p>
</li>
<li>
<p>调用stop：直接调用线程的stop()方法来结束改线程——容易造成死锁，不推荐</p>
<a id="more"></a>
</li>
</ul>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/image-20200420150209648.png" alt="image-20200420150209648"></p>
<h2 id="线程创建方式"><a class="header-anchor" href="#线程创建方式"></a>线程创建方式</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.继承Thread类</span></span><br><span class="line">        Thread1 thread = <span class="keyword">new</span> Thread1();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.实现Runnable接口</span></span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程2的run方法"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"主线程启动了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"子线程1的run方法"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程常用方法"><a class="header-anchor" href="#线程常用方法"></a>线程常用方法</h2>
<h3 id="线程的优先级"><a class="header-anchor" href="#线程的优先级"></a>线程的优先级</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只是修改线程抢到cpu时间片的概率</span></span><br><span class="line">        <span class="comment">//并不一定优先级高就能抢到</span></span><br><span class="line">        <span class="comment">//优先级是个整数 [1,10] 默认5 ，最高10</span></span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r, <span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r, <span class="string">"Thread2"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置优先级,必须在start方法之前设置</span></span><br><span class="line">        t1.setPriority(<span class="number">10</span>);</span><br><span class="line">        t2.setPriority(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的礼让"><a class="header-anchor" href="#线程的礼让"></a>线程的礼让</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程的礼让</span></span><br><span class="line"><span class="comment">* 放弃cpu时间片，然后重新抢夺，也可能还是抢到</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadYield</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Runnable r = () -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">3</span>)Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程并发"><a class="header-anchor" href="#多线程并发"></a>多线程并发</h2>
<h3 id="多线程卖票程序"><a class="header-anchor" href="#多线程卖票程序"></a>多线程卖票程序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceConflict</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable r = () -&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (TicketCenter.restTicket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"卖出一张票，剩余"</span>+--TicketCenter.restTicket+<span class="string">"张票"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread4"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketCenter</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> restTicket=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果 每次执行结果不同</span></span><br><span class="line"><span class="comment">//Thread4卖出一张票，剩余98张票</span></span><br><span class="line"><span class="comment">//Thread1卖出一张票，剩余97张票</span></span><br><span class="line"><span class="comment">//Thread3卖出一张票，剩余99张票</span></span><br><span class="line"><span class="comment">//Thread2卖出一张票，剩余99张票</span></span><br><span class="line"><span class="comment">//Thread3卖出一张票，剩余94张票</span></span><br><span class="line"><span class="comment">//Thread3卖出一张票，剩余92张票</span></span><br><span class="line"><span class="comment">//Thread1卖出一张票，剩余95张票</span></span><br><span class="line"><span class="comment">//Thread4卖出一张票，剩余96张票</span></span><br><span class="line"><span class="comment">//Thread4卖出一张票，剩余89张票</span></span><br><span class="line"><span class="comment">//……</span></span><br></pre></td></tr></table></figure>
<p>结果并不是我们想要得到的，是由于多线程并发时执行顺序导致出现的问题</p>
<h3 id="改进方法1-使用同步代码段"><a class="header-anchor" href="#改进方法1-使用同步代码段"></a>改进方法1 使用同步代码段</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable r = () -&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span> (TicketCenter.restTicket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//同步代码段</span></span><br><span class="line">                    <span class="comment">//synchronized小括号里面可以是对象也可以是类</span></span><br><span class="line">                    <span class="comment">//但是必须保证所以线程看到的锁是同一个</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="string">""</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (TicketCenter.restTicket&lt;=<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"卖出一张票，剩余"</span>+--TicketCenter.restTicket+<span class="string">"张票"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread4"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//Thread1卖出一张票，剩余99张票</span></span><br><span class="line"><span class="comment">//Thread1卖出一张票，剩余98张票</span></span><br><span class="line"><span class="comment">//Thread2卖出一张票，剩余97张票</span></span><br><span class="line"><span class="comment">//Thread2卖出一张票，剩余96张票</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="comment">//Thread2卖出一张票，剩余2张票</span></span><br><span class="line"><span class="comment">//Thread2卖出一张票，剩余1张票</span></span><br><span class="line"><span class="comment">//Thread2卖出一张票，剩余0张票</span></span><br></pre></td></tr></table></figure>
<h3 id="改进方法2-使用同步方法"><a class="header-anchor" href="#改进方法2-使用同步方法"></a>改进方法2 使用同步方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizeFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable r = SynchronizeFunction::sellTicket;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(r,<span class="string">"Thread4"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法为静态，则同步锁为类.class</span></span><br><span class="line"><span class="comment">     * 非静态，同步锁为this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (TicketCenter.restTicket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"卖出一张票，剩余"</span>+--TicketCenter.restTicket+<span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果同上</span></span><br></pre></td></tr></table></figure>
<h3 id="改进方法3-使用显式锁"><a class="header-anchor" href="#改进方法3-使用显式锁"></a>改进方法3 使用显式锁</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化一个锁对象</span></span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (TicketCenter.restTicket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (TicketCenter.restTicket &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"卖出一张票，剩余"</span> + --TicketCenter.restTicket + <span class="string">"张票"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r, <span class="string">"Thread1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r, <span class="string">"Thread2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(r, <span class="string">"Thread3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(r, <span class="string">"Thread4"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果同上</span></span><br></pre></td></tr></table></figure>
<h2 id="死锁"><a class="header-anchor" href="#死锁"></a>死锁</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多个线程彼此持有对方需要的锁标记而不释放自己的锁造成的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable r1 = ()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">"A"</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程1获取了锁A，等待锁B"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="string">"B"</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程1同时获取A和B"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable r2 = ()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">"B"</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程2获取了锁B，等待锁A"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="string">"A"</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程2同时获取A和B"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解除死锁"><a class="header-anchor" href="#解除死锁"></a>解除死锁</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">wait():等待，Object类中的一个方法，当前线程释放自己的锁标记，让出CPU资源，进入等待队列</span></span><br><span class="line"><span class="comment">notify()：通知，Object类中的一个方法，唤醒等待队列中的一个线程（由CPU调度），使这个线程进入锁池</span></span><br><span class="line"><span class="comment">notifyAll()：通知，Object类中的方法，唤醒等待队列中所有线程，并使这些线程进入锁池</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable r1 = ()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">"A"</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="string">"A"</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"线程1获取了锁A，等待锁B"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="string">"B"</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程1同时获取A和B"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable r2 = ()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">"B"</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程2获取了锁B，等待锁A"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="string">"A"</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程2同时获取A和B"</span>);</span><br><span class="line">                    <span class="string">"A"</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单例模式"><a class="header-anchor" href="#单例模式"></a>单例模式</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable r = Boss::getBoss;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Boss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1个Boss对象被实例化了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boss instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public static Boss getBoss()&#123;</span></span><br><span class="line"><span class="comment">        synchronized ("")&#123;</span></span><br><span class="line"><span class="comment">            if (instance==null)&#123;</span></span><br><span class="line"><span class="comment">                instance = new Boss();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return instance;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Boss <span class="title">getBoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) instance=<span class="keyword">new</span> Boss();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//1个Boss对象被实例化了</span></span><br></pre></td></tr></table></figure>
<p>每个线程访问的都是同一个对象</p>
<h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2>
<p>㊗️恭喜你看完了这篇文章！</p>
<p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p>
<p>📧<a href="mailto:yll1671158@163.com">我的邮箱</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里3月23日笔试</title>
    <url>/2020/03/23/%E9%98%BF%E9%87%8C3%E6%9C%8823%E6%97%A5%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<h2 id="第一题"><a class="header-anchor" href="#第一题"></a>第一题</h2>
<blockquote>
<p>输入一个整数n 1&lt;n&lt;10<sup>9</sup><br>
输出一个整数<br>
找出其所有非空子集中所有元素个数之和，然后对10<sup>9</sup>+7取模，输出结果<br>
例如输入2，有{1}，{2}，{1，2}3个非空子集，所有元素个数之和为4<br>
输出结果为4</p>
</blockquote>
<a id="more"></a>
<h3 id="思路"><a class="header-anchor" href="#思路"></a>思路</h3>
<p>用int肯定会超，需要用到BigInteger</p>
<p>对于输入n，求得所有元素之和为n*2<sup>n-1</sup></p>
<p>然后再对10<sup>9</sup>+7取模即可</p>
<h3 id="代码"><a class="header-anchor" href="#代码"></a>代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String n = sc.next();</span><br><span class="line">        BigInteger in = BigInteger.valueOf(Long.parseLong(n));</span><br><span class="line">        BigInteger num = f(in);<span class="comment">//种数</span></span><br><span class="line">        BigInteger x = BigInteger.valueOf(<span class="number">10</span>).pow(<span class="number">9</span>).add(BigInteger.valueOf(<span class="number">7</span>));</span><br><span class="line">        System.out.println(num.mod(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BigInteger <span class="title">f</span><span class="params">(BigInteger n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n.multiply(BigInteger.valueOf(<span class="number">2</span>).pow(n.intValue()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二题"><a class="header-anchor" href="#第二题"></a>第二题</h2>
<blockquote>
<p>输入n,m两个整数代表n行m列<br>
下面输入n行字符串，每个字符串都包含m个字符（只含有’.’,’#’,‘E’,‘S’）<br>
其中S代表起点，E代表终点，#代表无法通过<br>
从起点出发，可向左，向右，向上，向下移动一步<br>
也可按如下中心对称移动，也只算移动一步<br>
X（i,j）→  X‘（n+1-i,m+1-j）<br>
求从起点到终点最少需要移动几步</p>
</blockquote>
<p>示例输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">#S..</span><br><span class="line">E#..</span><br><span class="line">#...</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>说明<br>
先中心对称到达（4，3），然后向上一步，向右一步，中心对称到达终点</p>
<p>第2题我还没做完到时间了😭</p>
<h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2>
<p>㊗️恭喜你看完了这篇文章！</p>
<p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p>
<p>📧 <a href="mailto:yll1671158@163.com">我的邮箱</a></p>
]]></content>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/2020/03/14/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="hashmap的简单使用"><a class="header-anchor" href="#hashmap的简单使用"></a>HashMap的简单使用</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"a"</span>,<span class="string">"aaa"</span>);</span><br><span class="line">        map.put(<span class="string">"b"</span>,<span class="string">"bbb"</span>);</span><br><span class="line">        map.put(<span class="string">"c"</span>,<span class="string">"ccc"</span>);</span><br><span class="line">        map.put(<span class="string">"d"</span>,<span class="string">"ddd"</span>);</span><br><span class="line">        map.put(<span class="string">"e"</span>,<span class="string">"eee"</span>);</span><br><span class="line">        System.out.println(map.get(<span class="string">"a"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：aaa</span></span><br></pre></td></tr></table></figure>
<p>HashMap存储Key-Value（键值对）数据</p>
<a id="more"></a>
<h2 id="hashmap实现原理"><a class="header-anchor" href="#hashmap实现原理"></a>HashMap实现原理</h2>
<p>在Java8之前，通过数组+链表实现</p>
<p>Java8中，改为数组+链表+红黑树。当链表长度超过8时，将链表改为红黑树，降低数据查找的时间复杂度</p>
<p>HashMap成员</p>
<p>一个数组，数组里面每个元素都是链表</p>
<p>链表存储对象(Entry)：包括Key，Value，next，hash</p>
<h2 id="hashmap简单实现"><a class="header-anchor" href="#hashmap简单实现"></a>HashMap简单实现</h2>
<p>定义Map接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k,V v)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap简单实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组加链表</span></span><br><span class="line">    <span class="keyword">private</span> Entry&lt;K, V&gt;[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> defaultLength = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[defaultLength];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.key进行hash  2.对应数组下标  3.如果是null  4.是否可以存储</span></span><br><span class="line">        <span class="keyword">int</span> index = hash(k);</span><br><span class="line">        Entry&lt;K, V&gt; entry = table[index];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == entry) &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> Entry&lt;&gt;(k, v, <span class="keyword">null</span>, index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> Entry&lt;&gt;(k, v, entry, index);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> table[index].getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = k.hashCode() % (defaultLength - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.abs(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//hash出来的index  获取到当前Entry对象  判断对象有没有值  比较 在继续查找直到  key  hashcode</span></span><br><span class="line">        <span class="keyword">int</span> index = hash(k);</span><br><span class="line"></span><br><span class="line">        Entry&lt;K, V&gt; entry = getEntry(k, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> entry == <span class="keyword">null</span> ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry&lt;K, V&gt; <span class="title">getEntry</span><span class="params">(K k, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; entry = table[index]; entry != <span class="keyword">null</span>; entry = entry.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.hash == index &amp;&amp; (k == entry.getKey() || k.equals(entry.getKey()))) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span>  <span class="title">MyMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        MyHashMap.Entry&lt;K, V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K k, V v, MyHashMap.Entry&lt;K, V&gt; next, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyMap&lt;String, String&gt; map = <span class="keyword">new</span> MyHashMap();</span><br><span class="line">        map.put(<span class="string">"yll"</span>, <span class="string">"yll"</span>);</span><br><span class="line">        System.out.println(map.get(<span class="string">"yll"</span>));</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">yll</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这里只实现了Java8之前的数组加链表形式</p>
<h2 id="hashmap注意事项"><a class="header-anchor" href="#hashmap注意事项"></a>HashMap注意事项</h2>
<p>HashMap是线程不安全的，put方法和扩容时都是不安全的</p>
<p>但是get方法是线程安全的</p>
<h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2>
<p>㊗️恭喜你看完了这篇文章！</p>
<p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p>
<p>📧 <a href="mailto:yll1671158@163.com">我的邮箱</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows定时关机程序</title>
    <url>/2020/01/02/windows%E5%AE%9A%E6%97%B6%E5%85%B3%E6%9C%BA%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="原因"><a class="header-anchor" href="#原因"></a>原因</h2>
<blockquote>
<p>一坐在电脑前就停不下来，别的什么事情都忘了🤦‍♂️</p>
<p>每次说再看10分钟就不看了，往往1个小时之后都是还坐在电脑前的，尤其是晚上，老是因此熬夜。</p>
<p>所以干脆搞个定时自动关机，出其不意，一到时间电脑立刻关机，哈哈没想到吧😈</p>
</blockquote>
<p>在win10中简单搜了一下，好像没有定时关机的功能。cmd中是可以的啦，下面这个vbs其实也是用的cmd命令</p>
<a id="more"></a>
<h2 id="源码"><a class="header-anchor" href="#源码"></a>源码</h2>
<p>废话不多说，直接上代码。使用vbs实现，还是比较好懂的，我其实也没学过vbs，欢迎大佬批评指正。</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> ws=<span class="built_in">createobject</span>(<span class="string">"wscript.shell"</span>)</span><br><span class="line">x=<span class="built_in">msgbox</span>(<span class="string">"确定要关机吗？"</span>,vbYesNo)</span><br><span class="line"><span class="keyword">if</span> x=vbYes <span class="keyword">then</span></span><br><span class="line">    y=<span class="built_in">CDbl</span>(<span class="built_in">inputbox</span>(<span class="string">"输入数字(1~120)：x分钟后关机，取消立刻关机"</span>))</span><br><span class="line">    a=y*<span class="number">60</span></span><br><span class="line">    <span class="keyword">if</span> y&gt;=<span class="number">1</span> <span class="keyword">and</span> y&lt;=<span class="number">120</span> <span class="keyword">then</span></span><br><span class="line">        ws.run <span class="string">"cmd.exe /c shutdown -s -t"</span>&amp;<span class="string">" "</span>&amp;a </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ws.run <span class="string">"cmd.exe /c shutdown -s -t 0"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">msgbox</span>(<span class="string">"有重要的事情还是关掉电脑吧，还有，不要熬夜哦~"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>只有十几行代码，实际上就是使用<code>cmd</code>命令<code>shutdown</code>再加个时间来实现关机</p>
<p>⭐️声明：上面的代码可以自定义1-120分钟自动关机，如果输入1-120以外的数字或者点取消都会立刻关机。可以改<code>if y&gt;=1 and y&lt;=120</code>中的数字自行增加时间范围。</p>
<h2 id="使用方法"><a class="header-anchor" href="#使用方法"></a>使用方法</h2>
<ol>
<li>
<p>创建一个文本文件，改扩展名为shutdown.vbs，copy上面代码保存即可</p>
</li>
<li>
<p>双击shutdown.vbs文件运行</p>
</li>
</ol>
<blockquote>
<p>可以把这个文件放在桌面方便直接运行</p>
</blockquote>
<h2 id="效果展示"><a class="header-anchor" href="#效果展示"></a>效果展示</h2>
<p>输入25后确定（也就是25分钟后关机）</p>
<img src="https://gitee.com/yonglone/PicHub/raw/master/20200627121537.png" style="zoom:70%;" />
<h2 id="取消关机"><a class="header-anchor" href="#取消关机"></a>取消关机</h2>
<p>如果真的有紧急情况需要取消，可以在cmd中输入下面命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shutdown -a</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/yonglone/PicHub/raw/master/20200627121850.png" style="zoom:70%;" />
<blockquote>
<p>一般情况下就不要用了嘛，不然就没意义了。而且如果是立刻关机，应该是来不及取消的🐶</p>
</blockquote>
<p>但是windows有时候关机并不是直接就关了，它可能还会提醒有未保存的工作啥的，又给了一次苟延残喘的机会。。。</p>
<h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2>
<p>㊗️恭喜你看完了这篇文章！</p>
<p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p>
<p>📧 <a href="mailto:yll1671158@163.com">我的邮箱</a></p>
]]></content>
      <categories>
        <category>不知道分啥类</category>
      </categories>
      <tags>
        <tag>vbs</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2019/12/13/test/</url>
    <content><![CDATA[<p>这里有一个分割线</p>
<hr>
<a id="more"></a>
<p>I am here!</p>
<h2 id="测试居中"><a class="header-anchor" href="#测试居中"></a>测试居中</h2>
<!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
<!-- 其中 class="blockquote-center" 是必须的 -->
<blockquote class="blockquote-center">blah blah blah</blockquote>
<!-- 标签 方式，要求版本在0.4.5或以上 -->
<blockquote class="blockquote-center"><p>blah blah blah</p>
</blockquote>
<!-- 标签别名 -->
<blockquote class="blockquote-center"><p>blah blah blah</p>
</blockquote>
<blockquote class="blockquote-center"><p>测试居中</p>
</blockquote>
<h2 id="测试emoji"><a class="header-anchor" href="#测试emoji"></a>测试emoji</h2>
<p>⭐️ 💯 ☑️ 6️⃣ 5️⃣</p>
<p>🤙</p>
<h2 id="测试上标下标"><a class="header-anchor" href="#测试上标下标"></a>测试上标下标</h2>
<p>2<sup>2</sup></p>
<p>⭐️</p>
<p>2<sup>2</sup></p>
<p>H<sub>2</sub>O</p>
<h2 id="测试公式"><a class="header-anchor" href="#测试公式"></a>测试公式</h2>
<p>$$<br>
2+2=4<br>
$$</p>
<h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2>
<p>㊗️恭喜你看完了这篇文章！</p>
<p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p>
<p>📧 <a href="mailto:yll1671158@163.com">我的邮箱</a></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>一次给阿里巴巴fastjson修bug的学习经历</title>
    <url>/2019/12/11/%E4%B8%80%E6%AC%A1%E7%BB%99%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4fastjson%E4%BF%AEbug%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<blockquote>
<p>fastjson也是我最近有用到的一个开源库</p>
<p>这是我在B站学习到的，下面附上视频链接</p>
</blockquote>
<p><a href="https://www.bilibili.com/video/av77302131" target="_blank" rel="noopener">视频链接</a></p>
<a id="more"></a>
<h2 id="找bug标准"><a class="header-anchor" href="#找bug标准"></a>找bug标准</h2>
<ol>
<li>bug能复现</li>
<li>bug比较重要，也就是说很多人都出现过这个bug</li>
</ol>
<h2 id="找到bug"><a class="header-anchor" href="#找到bug"></a>找到bug</h2>
<p>找到的bug：fastjson无法反序列化超出某种限制的类#2779  下面有bug链接</p>
<p><a href="https://github.com/alibaba/fastjson/issues/2779" target="_blank" rel="noopener">bug链接</a></p>
<p>首先使用git clone fastjson项目，在idea中打开</p>
<p>进入test包，发现java.alibaba.fastjson.deserializer包下已经有issue2779的测试类了</p>
<p>当然，这是up主已经修复的版本啦，我们运行发现并没有报错，哈哈哈</p>
<h2 id="复现bug"><a class="header-anchor" href="#复现bug"></a>复现bug</h2>
<p>所以我们使用git回退到up主还没修复成功的版本</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/20200627123322.png" alt=""></p>
<p>他是11.4修复的，我们回退到下面的10.29</p>
<p>在此之前，我们可以先把issue2779包里面的两个文件在本地进行修改一下（按回车增加一行就可以），以免回退的时候这个包直接消失了</p>
<img src="https://gitee.com/yonglone/PicHub/raw/master/20200627133701.png" style="zoom:80%;" />
<p>上图选错了，应该选择Keep→Reset</p>
<p>看后面的信息就可以知道，选择keep本地修改的文件（也就是刚才修改的issue2779包内的两个文件）会保存下来了，如果选hard就直接暴力删除啦</p>
<p>之后运行issue2779测试类，终于出现了报错信息</p>
<img src="https://gitee.com/yonglone/PicHub/raw/master/20200627123844.png" style="zoom:80%;" />
<p>然后找这种jdk和这个项目报错信息的交界处</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/20200627134013.png" alt=""></p>
<p>也就是com.alibaba.fastjson.parser.deserializer包下面的ASMDeserializerFactory类的createJavaBeanDeserializer方法有问题</p>
<h2 id="查找问题"><a class="header-anchor" href="#查找问题"></a>查找问题</h2>
<p>我们定位到这一行，进行断点调试</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/duandiantiaoshi.png" alt="image-20191211115948426"></p>
<p>查看code变量</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/code.png" alt="image-20191202230532915"></p>
<blockquote>
<p>code是一个Java字节码</p>
<p>所有的.class 文件的前四个字节都是魔数，魔数的固定值为：0xCAFEBABE</p>
<p>Java有咖啡的意思，程序员的浪漫~</p>
<p>魔数的固定值是 Java 之父 James Gosling 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡</p>
</blockquote>
<h3 id="evaluate-expression表达式求值"><a class="header-anchor" href="#evaluate-expression表达式求值"></a>Evaluate Expression表达式求值</h3>
<p>在code处右键有个Evaluate Expression，表达式求值</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/evaluateexpression.png" alt="image-20191202230841162"></p>
<p>将字节码输出到文件bad.class</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/evaluate-writefile.png" alt="image-20191202231109760"></p>
<p>可以看到项目这里出现了bad.class文件</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/badclassloca.png" alt="image-20191211120602606"></p>
<p>很奇怪，我这里idea居然还是可以反编译成功</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/fanbianyibad.png" alt="image-20191211120750776"></p>
<p>如果是坏的，idea无法反编译，会出现下面的结果，视频中是这样的</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/badclass.png" alt="image-20191202234253689"></p>
<p>我们可以用一些工具来查看这个坏的字节码文件</p>
<p>例如下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -v bad #Java自带的反编译工具</span><br></pre></td></tr></table></figure>
<p>但是太长了，在命令行看也不太方便</p>
<p>我们使用下面的工具classpy</p>
<h3 id="反编译工具classpy"><a class="header-anchor" href="#反编译工具classpy"></a>反编译工具classpy</h3>
<p>在GitHub搜索classpy，clone下来，按照readme安装运行</p>
<p>我是Windows系统，首先进入classpy目录下，点击运行了gradlew.bat文件，然后在当前目录下的命令行输入下面的命令启动这个工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gradle run</span><br></pre></td></tr></table></figure>
<p>视频中他的Java版本为11，启动失败了</p>
<p>使用了jenv命令切换到jdk1.8，我使用的就是jdk1.8  忽略这个步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jenv shell 1.8  #需要安装jenv</span><br></pre></td></tr></table></figure>
<p>下面是打开的字节码文件</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/classpybadclass.png" alt="image-20191203001137874"></p>
<p>由于我们只有Illegal target of jump or branch这个报错信息，这一个线索</p>
<blockquote>
<p>下面buildjdk操作太硬核，我没有跟着做😂  感兴趣可以去视频16:45处看看👍</p>
</blockquote>
<p>到jdk中寻找此报错信息</p>
<p>clone openjdk下的jdk项目，全局搜索此报错信息Illegal target of jump or branch</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/errorInfoLocaInJDK.png" alt="Illegal target of jump or branch 报错信息"></p>
<p>然后他修改了jdk，上面图片中的代码就是修改后的jdk，原来只有报错信息，他自己加上了jump和target，可以提示错误的位置，如下图</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/changeJDK.png" alt="image-20191211131058621"></p>
<p>然后他自己build了一个jdk👍</p>
<p>使用自己build的jdk重新运行issue2779，下面是报错信息，deserialze方法第50位置</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/errorInJDK.png" alt="image-20191211131737775"></p>
<p>在刚才classpy打开的bad.class中找到deserialze方法  字节码  第50个位置是这样的</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/bytecode_50.png" alt="image-20191211124952950"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifeq -32405</span><br></pre></td></tr></table></figure>
<p>可能是溢出</p>
<p>查看ifeq的含义，当栈顶int型数值等于0时跳转</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/ifeq.png" alt="image-20191211132443946"></p>
<p>fastjson有个地方代码没有写好，生成了一个会溢出的跳转指令</p>
<p>然后根据上下文(50位置上面有个isEnabled)，在源码中找到相应位置</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/errorloca.png" alt="image-20191211125555537"></p>
<p>进入visitJumpInsn方法，这其实是asm代码（操作字节码的库）</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/asmInterf.png" alt="image-20191211133402454"></p>
<p>按crtl+alt+B可以进入接口的实现类</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/asmImpl.png" alt="image-20191211133434998"></p>
<h2 id="解决问题"><a class="header-anchor" href="#解决问题"></a>解决问题</h2>
<p>然后他觉得，可能是fastjson里面的asm代码版本太老了，想把最新的合并进来，但是由于版本相差7年，失败了</p>
<p>对比最新的asm代码与fastjson里面的代码</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/changeCode.png" alt="image-20191211133753383"></p>
<p>这里非常重要，如果越界，可以将IFxxx改为IFNOTxxx  GOTO_W</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/annotation.png" alt="image-20191211175328263"></p>
<p>最后解决的问题：按照asm的要求，把一个不支持长跳转的ifeq转变成ifnq加goto_w长跳转语句</p>
<p><a href="https://github.com/alibaba/fastjson/pull/2858" target="_blank" rel="noopener">pr链接</a></p>
<p>修完bug一定要补一个测试用例！</p>
<h2 id="视频中提到其他内容"><a class="header-anchor" href="#视频中提到其他内容"></a>视频中提到其他内容</h2>
<h3 id="字节码的解释："><a class="header-anchor" href="#字节码的解释："></a>字节码的解释：</h3>
<p>简单写一个测试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbcDTO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>,j=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i+j==<span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，使用ASM Bytecode Viewer插件查看字节码</p>
<h3 id="asm-bytecode-viewer插件"><a class="header-anchor" href="#asm-bytecode-viewer插件"></a>ASM Bytecode Viewer插件</h3>
<p>可在idea Plugins中安装</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/asmplugin.png" alt="image-20191208144452139"></p>
<p>找到main方法</p>
<p><img src="https://gitee.com/yonglone/PicHub/raw/master/JavaBytecode.png" alt="image-20191208144825554"></p>
<p>每个方法里面有个操作数栈，jvm执行方法时会不停的执行这些指令</p>
<h3 id="修bug要掌握的东西"><a class="header-anchor" href="#修bug要掌握的东西"></a>修bug要掌握的东西</h3>
<ol>
<li>能从用户提供的bug，重现bug</li>
<li>看栈轨迹，字节码问题出在哪里</li>
<li>学习使用反编译工具</li>
<li>错误信息到底是什么问题，读jdk源码（甚至需要build jdk）</li>
</ol>
<p>R大的书单RednaxelaFX</p>
<p>下·</p>
<h3 id="mybatis需要掌握的内容"><a class="header-anchor" href="#mybatis需要掌握的内容"></a>mybatis需要掌握的内容</h3>
<ol>
<li>#{} ${}</li>
<li>缓存是咋实现的？</li>
<li>Executor是啥？</li>
<li>分页是怎么实现的？</li>
</ol>
<h2 id="总结一下看这个视频了解到的内容"><a class="header-anchor" href="#总结一下看这个视频了解到的内容"></a>总结一下看这个视频了解到的内容</h2>
<ul>
<li>
<p>Java字节码的magic number  Cofe Babe</p>
</li>
<li>
<p>idea的表达式计算Evaluate Expression</p>
</li>
<li>
<p>学习使用反编译工具javap -v 、classpy</p>
</li>
<li>
<p>ASM Bytecode Viewer插件查看字节码</p>
</li>
<li>
<p>话说我才刚知道idea中快捷键CTRL+Alt+B可以从接口跳转到实现类😂然后Ctrl+U是实现类到接口🤣</p>
</li>
<li>
<p>GitHub中的issue以及pull request</p>
</li>
</ul>
<h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2>
<p>㊗️恭喜你看完了这篇文章！</p>
<p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p>
<p>📧 <a href="mailto:yll1671158@163.com">我的邮箱</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验3 存储管理</title>
    <url>/2019/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="实验目的"><a class="header-anchor" href="#实验目的"></a>实验目的</h2>
<p>理解操作系统存储管理原理</p>
<blockquote>
<p>操作系统的发展使得系统完成了大部分的内存管理工作。对于程序员而言，这些内存管理的过程完全透明不可见。因此，程序员开发时从不关心系统如何为自己分配内存，而且永远认为系统可以分配给程序所需要的内存。在程序开发时，程序员真正需要做的就是：申请内存、使用内存、释放内存，其他一概无需过问。</p>
</blockquote>
<a id="more"></a>
<h2 id="实验内容"><a class="header-anchor" href="#实验内容"></a>实验内容</h2>
<h3 id="程序1"><a class="header-anchor" href="#程序1"></a>程序1</h3>
<p>申请内存、使用内存以及释放一块内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//B17040417.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> * str;</span><br><span class="line"><span class="keyword">if</span> ((str=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"not enough memory to allocate buffer\\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"string is %s\n"</span>,str);</span><br><span class="line"><span class="built_in">free</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序2"><a class="header-anchor" href="#程序2"></a>程序2</h3>
<p>在打开文件后，通过fstat()获得文件长度，然后通过malloc()系统调用申请响应大小的内存空间，通过read()将文件内容完全读入该内存空间，并显示出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//yanglonglong.c(路径: /opt/yanglonglong.c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd,len;</span><br><span class="line">  <span class="keyword">void</span> *tp;<span class="comment">//void *则为“无类型指针”，可以指向任何数据类型</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">ps</span>;</span></span><br><span class="line">  fd=<span class="built_in">open</span>(<span class="string">"/opt/yanglonglong.c"</span>,<span class="number">0</span>);</span><br><span class="line">  fstat(fd,&amp;ps);</span><br><span class="line">  len=ps.st_size;</span><br><span class="line">  tp=<span class="built_in">malloc</span>(len);</span><br><span class="line">  <span class="built_in">read</span>(fd,tp,len);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,tp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size:%d bytes\n"</span>,len);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="知识点"><a class="header-anchor" href="#知识点"></a>知识点</h2>
<h3 id="实验指导内容"><a class="header-anchor" href="#实验指导内容"></a>实验指导内容</h3>
<h4 id="1-内存动态分配函数"><a class="header-anchor" href="#1-内存动态分配函数"></a>1）内存动态分配函数</h4>
<p>#include &lt;malloc.h&gt;</p>
<p>void *malloc(size_t size)</p>
<p>该函数分配指定大小size个字节的内存空间，成功时返回分配内存的指针（即所分配内存的地址）。该内存区域没有清空。</p>
<h4 id="2-void-free-void-addr"><a class="header-anchor" href="#2-void-free-void-addr"></a>2） void free(void * addr);</h4>
<p>该函数释放由malloc()分配的内存，addr是要释放内存空间的起始地址，并且addr必须是被以前malloc( )调用返回的。</p>
<h3 id="网上查阅内容"><a class="header-anchor" href="#网上查阅内容"></a>网上查阅内容</h3>
<h4 id="malloc的使用方法及注意事项"><a class="header-anchor" href="#malloc的使用方法及注意事项"></a>malloc的使用方法及注意事项</h4>
<p>使用C语言进行开发的时候,内存管理非常重要,如果内存管理不当,会导致内存泄露,程序无故死机,<br>
在C语言中内存管理中,需要使用malloc()和free()两个函数</p>
<h5 id="1-为什么要使用malloc和free"><a class="header-anchor" href="#1-为什么要使用malloc和free"></a>1 为什么要使用malloc和free ?</h5>
<p>使用malloc,free可以动态的分配内存和动态释放内存,节约应用程序的运行时,所占用的内存空间,以上也是malloc的优点。</p>
<h5 id="2-malloc和指针的关系"><a class="header-anchor" href="#2-malloc和指针的关系"></a>2 malloc和指针的关系?</h5>
<p>void p= *malloc(long num)：该函数分配了num个字节,并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。<br>
关于分配失败的原因，应该有多种，比如说空间不足就是一种。<br>
void free§： 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存,让这块内存重新交给操作系统管理。<br>
综上所述：因为malloc分配成功后返回内存的首地址，在使用中是按地址来进行调用，所以有malloc分配内存的时候，就有指针存在。</p>
<h5 id="3-一般什么情况下需要用到malloc"><a class="header-anchor" href="#3-一般什么情况下需要用到malloc"></a>3 一般什么情况下需要用到malloc ?</h5>
<p>在程序运行的时候，可变的array,struct可以用到malloc分配内存，也可以采用分配一个连续的空间 存储一批相同类型的变量。</p>
<h5 id="4-malloc的用法"><a class="header-anchor" href="#4-malloc的用法"></a>4 malloc的用法</h5>
<p>程序代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p= (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">//分配100个字符串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == p) <span class="comment">//检测malloc是否分配成功</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用分配空间</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放空间</span></span><br><span class="line">p= <span class="literal">NULL</span>; <span class="comment">//指针释放</span></span><br></pre></td></tr></table></figure>
<h5 id="5-malloc使用注意事项"><a class="header-anchor" href="#5-malloc使用注意事项"></a>5 malloc使用注意事项</h5>
<ol>
<li>malloc内存空间后,需要检查是否分配成功!</li>
<li>使用完毕后需要释放内存空间，释放后应该把指向这块内存的指针指向NULL,避免再次使用时，出现奇怪的错误现象。</li>
<li>malloc内存后，不释放会产生内存泄露，多次使用free释放会导致程序报错。</li>
<li>malloc内存时候，需要对返回的指针类型做强制转换。</li>
</ol>
<h4 id="read函数"><a class="header-anchor" href="#read函数"></a>read函数</h4>
<p>用read函数读取数组中的元素：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>第一个参数说明的是从0开始读取<br>
第二个参数是：要读取的数组buf<br>
第三个参数是：要读5个</p>
<p>总结：从第0个开始读取buf中的5个元素（连续的）</p>
<h4 id="fstat"><a class="header-anchor" href="#fstat"></a>fstat</h4>
<p>功能：<br>
获得文件或共享内存区的信息<br>
头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntk.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>函数原形：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name,struct stat *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数：<br>
file_name          文件名<br>
buf                     stat结构<br>
返回值：<br>
成功返回0，出错返回-1<br>
对于普通文件stat结构可以获得12个以上的成员信息，然而当fd指代一个共享内存区对象时，只有四个成员含有信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>&#123;</span></span><br><span class="line">	<span class="keyword">mode_t</span> st_mode;</span><br><span class="line">	<span class="keyword">uid_t</span> st_uid;</span><br><span class="line">	<span class="keyword">gid_t</span> st_gid;</span><br><span class="line">	<span class="keyword">off_t</span> st_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="exit-函数"><a class="header-anchor" href="#exit-函数"></a>exit()函数:</h4>
<p>所在头文件：<strong>stdlib.h</strong><br>
功 能: 关闭所有文件，终止正在执行的进程。<br>
exit(1)表示异常退出.这个1是返回给操作系统的。<br>
exit(x)（x不为0）都表示异常退出<br>
exit(0)表示正常退出<br>
exit()的参数会被传递给一些操作系统，包括UNIX,Linux,和MS DOS，以供其他程序使用。<br>
<strong>stdlib.h</strong>: void exit(int status);<br>
参 数 : status //程序退出的返回值.</p>
<h4 id="exit函数和return函数的主要区别："><a class="header-anchor" href="#exit函数和return函数的主要区别："></a>exit函数和return函数的主要区别：</h4>
<p>1）exit用于在程序运行的过程中随时结束程序，exit的参数是返回给OS的。main函数结束时也会隐式地调用exit函数。exit函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile()创建的临时文件。exit是结束一个进程，它将删除进程使用的内存空间，同时把错误信息返回父进程,而return是返回函数值并退出函数。通常情况：</p>
<ul>
<li>
<p>exit(0)表示程序正常,</p>
</li>
<li>
<p>exit(1)和exit(-1)表示程序异常退出，exit(2)表示表示系统找不到指定的文件。</p>
</li>
</ul>
<p>在整个程序中，只要调用exit就结束（当前进程或者在main时候为整个程序）。</p>
<p>2）return是语言级别的，它表示了调用堆栈的返回；return( )是当前函数返回，当然如果是在主函数main, 自然也就结束当前进程了，如果不是，那就是退回上一层调用。在多个进程时。如果有时要检测上个进程是否正常退出。就要用到上个进程的返回值，依次类推。而exit是系统调用级别的，它表示了一个进程的结束。</p>
<p>3）exit函数是退出应用程序，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息。</p>
<p>4）和机器和操作系统有关的一般是： 0为正常退出，非0为非正常退出；</p>
<h4 id="进程环境与进程控制"><a class="header-anchor" href="#进程环境与进程控制"></a>进程环境与进程控制</h4>
<p>​		exit(int n)其实就是直接退出程序，因为默认的标准程序入口为 int main(int argc, char** argv)，返回值是int型的。一般在shell下面，运行一个程序，然后使用命令echo $?就能得到该程序的返回值，也就是退出值，在main()里面，你可以用return n，也能够直接用exit(n)来做。unix默认的正确退出是返回0，错误返回非0。</p>
<p>理论上exit可以返回小于256的任何整数。返回的不同数值主要是给调用者作不同处理的。</p>
<p>单独的进程是返回给操作系统的。如果是多进程，是返回给父进程的。父进程里面调用waitpid()等函数得到子进程退出的状态，以便作不同处理。根据相应的返回值来让调用者作出相应的处理.总的说来，exit（）就是当前进程把控制权返回给调用该程序的程序,括号里的是返回值,告诉调用程序该程序的运行状态。</p>
<h5 id="1-进程的开始："><a class="header-anchor" href="#1-进程的开始："></a>1） 进程的开始：</h5>
<p>C程序是从main函数开始执行, 原型如下:int main(int argc, char *argv[]);通常main的返回值是int型, 正确返回0。如果main的返回值为void, 某些编译器会给出警告, 此时main的返回值通常是0。</p>
<h5 id="2-进程终止："><a class="header-anchor" href="#2-进程终止："></a>2）进程终止：</h5>
<p>C程序的终止分为两种: 正常终止和异常终止。正常终止分为: return, exit, _exit, _Exit, pthreade_exit。异常中指分为: abort, SIGNAL, 线程响应取消。<br>
主要说一下正常终止的前4种, 即exit系列函数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;   </span></span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<p>以上3个函数的区别是:exit()(或return 0)会调用终止处理程序和用户空间的标准I/O清理程序(如fclose), <em>exit和</em> Exit不调用而直接由内核接管进行清理。<strong>因此, 在main函数中exit(0)等价于return 0</strong></p>
<h5 id="3-atexit终止处理程序："><a class="header-anchor" href="#3-atexit终止处理程序："></a>3） atexit终止处理程序：</h5>
<p>ISO C规定, 一个进程最多可登记32个终止处理函数, 这些函数由exit按登记相反的顺序自动调用。如果同一函数登记多次, 也会被调用多次。<br>
原型如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中参数是一个函数指针, 指向终止处理函数, 该函数无参无返回值。atexit函数本身成功调用后返回0。</p>
<p>以下面的程序为例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myexit1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"first exit handler\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myexit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"second exit handler\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atexit(my_exit2)；</span><br><span class="line">  atexit(my_exit1)； </span><br><span class="line"></span><br><span class="line">atexit(my_exit1)；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main is done\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;a.out</span><br><span class="line">main is done</span><br><span class="line">first exit handler</span><br><span class="line">first exit handler</span><br><span class="line">second exit handler</span><br></pre></td></tr></table></figure>
<p>注意上面的结果，可以发现这些函数由exit按登记相反的顺序自动调用（先myexit1后myexit2）。如果同一函数登记多次, 也会被调用多次（如这里的myexit1）。而这些处理函数都是在程序退出的时候利用atexit函数调用了这些处理函数。但是如果用_exit()退出程序，则它不关闭任何文件，不清除任何缓冲器、也不调用任何终止函数！</p>
<h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2>
<p>㊗️恭喜你看完了这篇文章！</p>
<p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p>
<p>📧 <a href="mailto:yll1671158@163.com">我的邮箱</a></p>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学复习</title>
    <url>/2019/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://learnopengl-cn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">OpenGL官方文档链接</a></p>
<blockquote>
<p>此博客用来学习OpenGL知识以及相关函数的学习，不包含完整项目的源码</p>
</blockquote>
<a id="more"></a>
<h2 id="起步"><a class="header-anchor" href="#起步"></a>起步</h2>
<p>开发环境vs2017</p>
<p>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。</p>
<p>OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在Windows上会是类似这样：</p>
<p>了解即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*GL_GENBUFFERS)</span> <span class="params">(GLsizei, GLuint*)</span></span>;</span><br><span class="line"><span class="comment">// 找到正确的函数并赋值给函数指针</span></span><br><span class="line">GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress(<span class="string">"glGenBuffers"</span>);</span><br><span class="line"><span class="comment">// 现在函数可以被正常调用了</span></span><br><span class="line">GLuint <span class="built_in">buffer</span>;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;<span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到代码非常复杂，而且很繁琐，我们需要对每个可能使用的函数都要重复这个过程。幸运的是，有些库能简化此过程，其中<strong>GLEW</strong>是目前最新，也是最流行的库。</p>
<p>GLEW是OpenGL Extension Wrangler Library的缩写，它能解决我们上面提到的那个繁琐的问题。因为GLEW也是一个库，我们同样需要构建并将其链接进工程。</p>
<h3 id="静态链接与动态链接"><a class="header-anchor" href="#静态链接与动态链接"></a>静态链接与动态链接</h3>
<p><strong>静态</strong>(Static)链接是指编译时就将库代码里的内容整合进你的二进制文件。优点就是你不需要管理额外的文件了，只需要发布你单独的一个二进制文件就行了。缺点就是你的可执行文件会变得更大，另外当库有升级版本时，你必须重新进行编译整个程序。</p>
<p><strong>动态</strong>(Dynamic)链接是指一个库通过<code>.dll</code>或<code>.so</code>的方式存在，它的代码与你的二进制文件的代码是分离的。优点是使你的二进制文件大小变小并且更容易升级，缺点是你最终发布程序时必须带上这些DLL。</p>
<p>静态链接GLEW，必须在包含GLEW头文件之前定义预处理器宏<code>GLEW_STATIC</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="创建窗口"><a class="header-anchor" href="#创建窗口"></a>创建窗口</h2>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//GLEW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GLFW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> GLint WIDTH = <span class="number">800</span>, HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	glfwInit();<span class="comment">//初始化glfw</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//配置GLFW</span></span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//配置GLFW</span></span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">// must for Mac</span></span><br><span class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//glfwCreateWindow函数需要窗口的宽和高作为它的前两个参数；第三个参数表示这个窗口的名称（标题）；最后两个参数我们暂时忽略，先设置为空指针就行。</span></span><br><span class="line">	GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, <span class="string">"Learn OpenGL"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> == window)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		glfwTerminate();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GLEW是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLEW</span></span><br><span class="line">	glewExperimental = GL_TRUE;</span><br><span class="line">	<span class="keyword">if</span> (GLEW_OK != glewInit()) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialise GLEW"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> screenWidth, screenHeight;</span><br><span class="line">	glfwGetFramebufferSize(window, &amp;screenWidth, &amp;screenHeight);</span><br><span class="line">    <span class="comment">/*可以通过调用glViewport函数来设置窗口的维度(Dimension)</span></span><br><span class="line"><span class="comment">    前两个参数控制窗口左下角的位置；第三个和第四个参数控制渲染窗口的宽度和高度（像素）*/</span></span><br><span class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, screenWidth, screenHeight);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*我们可不希望只绘制一个图像之后我们的应用程序就立即退出并关闭窗口。</span></span><br><span class="line"><span class="comment">    因此，我们需要在程序中添加一个while循环，它能在我们让GLFW退出前一直保持运行。*/</span></span><br><span class="line">    <span class="comment">//glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后游戏循环便结束了，之后为我们就可以关闭应用程序了。</span></span><br><span class="line">	<span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等），然后调用对应的回调函数（可以通过回调方法手动设置）。我们一般在游戏循环的开始调用事件处理函数。</span></span><br><span class="line">		glfwPollEvents();</span><br><span class="line">		glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">		glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">//glfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上</span></span><br><span class="line">		glfwSwapBuffers(window);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//当游戏循环结束后我们需要正确释放/删除之前的分配的所有资源。我们可以在main函数的最后调用glfwTerminate函数来释放GLFW分配的内存</span></span><br><span class="line">	glfwTerminate();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三角形"><a class="header-anchor" href="#三角形"></a>三角形</h2>
<p>OpenGL的大部分工作都是把3D坐标转变为适应你屏幕的2D像素。</p>
<p>3D坐标转为2D坐标的处理过程是由OpenGL的<strong>图形渲染管线</strong>（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。</p>
<h3 id="顶点着色器"><a class="header-anchor" href="#顶点着色器"></a>顶点着色器</h3>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position.x, position.y, position.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>in</code>关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)</p>
<p>图形渲染管线的第一个部分是**顶点着色器(**Vertex Shader)，它把一个单独的顶点作为输入。目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>
<p><strong>图元装配</strong>(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入，并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p>
<p>OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把<strong>所有的</strong>3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。</p>
<p>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以<strong>标准化设备坐标</strong>的形式（OpenGL的可见区域）定义为一个<code>GLfloat</code>数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们渲染的是一个2D三角形，将它顶点的z坐标设置为0.0。</p>
<p>定义顶点数据以后，我们会把它作为输入发送顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p>
<h3 id="顶点缓存对象vbo"><a class="header-anchor" href="#顶点缓存对象vbo"></a>顶点缓存对象VBO</h3>
<p>我们通过<strong>顶点缓冲对象</strong>(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存(通常被称为显存)中<strong>储存大量顶点</strong>。</p>
<p>顶点缓冲对象是我们在OpenGL教程中第一个OpenGL对象。这个缓冲有一个独一无二的ID，我们可以使用<u><em>glGenBuffers</em></u>函数和一个缓冲ID生成一个VBO对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLuint VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br></pre></td></tr></table></figure>
<p>顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER</p>
<p>我们可以使用<u><em>glBindBuffer</em></u>函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br></pre></td></tr></table></figure>
<p>从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用<u><em>glBufferData</em></u>函数，它会把之前定义的顶点数据复制到缓冲的内存中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。</p>
<ol>
<li>
<p>第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。</p>
</li>
<li>
<p>第二个参数指定传输数据的大小(以字节为单位)；用一个简单的<code>sizeof</code>计算出顶点数据大小就行。</p>
</li>
<li>
<p>第三个参数是我们希望发送的实际数据。</p>
</li>
<li>
<p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p>
</li>
</ol>
<ul>
<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>
</ul>
<p>我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为<code>GLuint</code>，然后用<u><em>glCreateShader</em></u>创建这个着色器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLuint vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure>
<p>我们把需要创建的着色器类型以参数形式提供给glCreateShader。由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER。</p>
<p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure>
<p>glShaderSource函数把</p>
<p>要编译的着色器对象作为第一个参数。</p>
<p>第二参数指定了传递的源码字符串数量，这里只有一个。</p>
<p>第三个参数是顶点着色器真正的源码，</p>
<p>第四个参数我们先设置为<code>NULL</code>。</p>
<h3 id="片段着色器"><a class="header-anchor" href="#片段着色器"></a>片段着色器</h3>
<p>片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器全是关于计算你的像素最后的颜色输出。</p>
<p>片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    color = <span class="type">vec4</span>(<span class="number">1.0</span>f, <span class="number">0.5</span>f, <span class="number">0.2</span>f, <span class="number">1.0</span>f);<span class="comment">//第四个参数 1.0代表完全不透明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>out</code>关键字声明输出变量</p>
<p>编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLuint fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, null);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。</p>
<h3 id="着色器程序"><a class="header-anchor" href="#着色器程序"></a>着色器程序</h3>
<p>着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。</p>
<p>创建一个程序对象很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLuint shaderProgram;</span><br><span class="line">shaderProgram &#x3D; glCreateProgram();</span><br></pre></td></tr></table></figure>
<p>glCreateProgram函数创建一个程序，并返回新创建程序对象的ID引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用glLinkProgram链接它们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure>
<p>我们把着色器附加到了程序上，然后用glLinkProgram链接。</p>
<p>得到的结果就是一个程序对象，我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br></pre></td></tr></table></figure>
<p>在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。</p>
<p>对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure>
<h3 id="链接顶点属性"><a class="header-anchor" href="#链接顶点属性"></a>链接顶点属性</h3>
<p>顶点着色器允许我们指定任何以顶点属性为形式的输入。意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。</p>
<p>我们的顶点缓冲数据会被解析为下面这样子：</p>
<p><img src="https://learnopengl-cn.readthedocs.io/zh/latest/img/01/04/vertex_attribute_pointer.png" alt="img"></p>
<ul>
<li>位置数据被储存为32-bit（4字节）浮点值。</li>
<li>每个位置包含3个这样的值。</li>
<li>在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列。</li>
<li>数据中第一个值在缓冲开始的位置。</li>
</ul>
<p>有了这些信息我们就可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>glVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们：</p>
<ul>
<li>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为<code>0</code>。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入<code>0</code>。</li>
<li>第二个参数指定顶点属性的大小。顶点属性是一个<code>vec3</code>，它由3个值组成，所以大小是3。</li>
<li>第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中<code>vec*</code>都是由浮点数值组成的)。</li>
<li>下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。</li>
<li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个<code>GLfloat</code>之后，我们把步长设置为<code>3 * sizeof(GLfloat)</code>。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子(译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节)。</li>
<li>最后一个参数的类型是<code>GLvoid*</code>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</li>
</ul>
<blockquote>
<p>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVetexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVetexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性<code>0</code>现在会链接到它的顶点数据。</p>
</blockquote>
<p>在OpenGL中绘制一个物体，代码会像是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 复制顶点数组到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 1. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line"><span class="comment">//glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 当我们渲染一个物体时要使用着色器程序</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// 3. 绘制物体</span></span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure>
<h3 id="顶点数组对象vao"><a class="header-anchor" href="#顶点数组对象vao"></a>顶点数组对象VAO</h3>
<p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。</p>
<p>一个顶点数组对象会储存以下这些内容：</p>
<ul>
<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>
<li>通过glVertexAttribPointer设置的顶点属性配置。</li>
<li>通过<code>glVertexAttribPointer</code>调用进行的顶点缓冲对象与顶点属性链接。</li>
</ul>
<p>创建一个VAO和创建一个VBO很类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLuint VAO;</span><br><span class="line">glGenVertexArrays(1, &amp;VAO);</span><br></pre></td></tr></table></figure>
<p>要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//4. 解绑VAO</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代（游戏循环中） :: ..</span></span><br><span class="line"><span class="comment">// 5. 绘制物体</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>要想绘制我们想要的物体，OpenGL给我们提供了glDrawArrays函数，它使用当前激活的着色器，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line">glBindVertexArray(0);</span><br></pre></td></tr></table></figure>
<p>glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。第二个参数指定了顶点数组的起始索引，我们这里填<code>0</code>。最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。</p>
<h3 id="索引缓冲对象"><a class="header-anchor" href="#索引缓冲对象"></a>索引缓冲对象</h3>
<p>在渲染顶点这一话题上我们还有最有一个需要讨论的东西——索引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLfloat vertices[] &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一个三角形</span><br><span class="line">    0.5f, 0.5f, 0.0f,   &#x2F;&#x2F; 右上角</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f,  &#x2F;&#x2F; 左上角</span><br><span class="line">    &#x2F;&#x2F; 第二个三角形</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f   &#x2F;&#x2F; 左上角</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，有几个顶点叠加了。我们指定了<code>右下角</code>和<code>左上角</code>两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果OpenGL提供这个功能就好了，对吧？</p>
<p>很幸运，索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（独一无二的）顶点，和绘制出矩形所需的索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLfloat vertices[] &#x3D; &#123;</span><br><span class="line">    0.5f, 0.5f, 0.0f,   &#x2F;&#x2F; 右上角</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f   &#x2F;&#x2F; 左上角</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GLuint indices[] &#x3D; &#123; &#x2F;&#x2F; 注意索引从0开始! </span><br><span class="line">    0, 1, 3, &#x2F;&#x2F; 第一个三角形</span><br><span class="line">    1, 2, 3  &#x2F;&#x2F; 第二个三角形</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你可以看到，当时用索引的时候，我们只定义了4个顶点，而不是6个。下一步我们需要创建索引缓冲对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLuint EBO;</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br></pre></td></tr></table></figure>
<p>与VBO类似，我们先绑定EBO然后用glBufferData把索引复制到缓冲里。同样，和VBO类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>要注意的是，我们传递了GL_ELEMENT_ARRAY_BUFFER当作缓冲目标。最后一件要做的事是用glDrawElements来替换glDrawArrays函数，来指明我们从索引缓冲渲染。使用glDrawElements时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span><br></pre></td></tr></table></figure>
<p>第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。第三个参数是索引的类型，这里是GL_UNSIGNED_INT。最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。</p>
<p>glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。</p>
<p>最后的初始化和绘制代码现在看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码 :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 设定顶点属性指针</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 4. 解绑VAO（不是EBO！）</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（游戏循环中） :: ..</span></span><br><span class="line"></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="colorful🔺"><a class="header-anchor" href="#colorful🔺"></a>colorful🔺</h3>
<p>把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用<code>layout</code>标识符来把color属性的位置值设置为1：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position; <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> color;    <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = color; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们不再使用uniform来传递片段的颜色了，现在使用<code>ourColor</code>输出变量，我们必须再修改一下片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    color = <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。更新后的VBO内存中的数据现在看起来像这样：</p>
<p><img src="https://learnopengl-cn.readthedocs.io/zh/latest/img/01/05/vertex_attribute_pointer_interleaved.png" alt="img"></p>
<p>知道了现在使用的布局，我们就可以使用glVertexAttribPointer函数更新顶点格式，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)(<span class="number">3</span>* <span class="keyword">sizeof</span>(GLfloat)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>glVertexAttribPointer函数的前几个参数比较明了。这次我们配置属性位置值为1的顶点属性。颜色值有3个float那么大，我们不去标准化这些值。</p>
<p>由于我们现在有了两个顶点属性，我们不得不重新计算<strong>步长</strong>值。为获得数据队列中下一个属性值（比如位置向量的下个<code>x</code>分量）我们必须向右移动6个float，其中3个是位置值，另外3个是颜色值。这使我们的步长值为6乘以float的字节数（=24字节）。<br>
同样，这次我们必须指定一个偏移量。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以偏移量就是<code>3 * sizeof(GLfloat)</code>，用字节来计算就是12字节。</p>
<p>运行程序你应该会看到如下结果：</p>
<p><img src="https://learnopengl-cn.readthedocs.io/zh/latest/img/01/05/shaders3.png" alt="img"></p>
<h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2>
<p>㊗️恭喜你看完了这篇文章！</p>
<p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p>
<p>📧 <a href="mailto:yll1671158@163.com">我的邮箱</a></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2019/09/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="搭建博客"><a class="header-anchor" href="#搭建博客"></a>搭建博客</h2>
<ol>
<li>安装node和git</li>
</ol>
<p>在Windows中查看是否成功安装node<br>
win + R 输入cmd打开命令行窗口<br>
输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p>回车后看到版本号</p>
<a id="more"></a>
<p>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>同样看到版本号即表示安装成功</p>
<p>2.安装hexo</p>
<ol>
<li>安装cnpm</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>安装成功后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm</span><br></pre></td></tr></table></figure>
<p>可以看到相应信息</p>
<ol start="2">
<li>安装hexo</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装成功后可输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>验证是否成功</p>
<p>3.选择一个路径，新建文件夹blog(当然也可以用其他名称)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line"><span class="built_in">cd</span> blog     //进入blog文件夹</span><br><span class="line">hexo init  //初始化文件夹，漫长的等待。。。</span><br></pre></td></tr></table></figure>
<p>如果出现了错误，可以删掉blog文件夹，从新建文件夹blog重新开始<br>
成功后可以看到blog文件夹下生成了一些文件<br>
然后就可以启动博客了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>可以看到输出如下信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>在浏览器输入localhost:4000回车就可以看到博客了<br>
如下图<br>
<img src="https://img-blog.csdnimg.cn/20190927224717553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVweWFuZw==,size_16,color_FFFFFF,t_70" alt="博客页面"><br>
默认生成了一篇Hello World的文章</p>
<h3 id="新建文章"><a class="header-anchor" href="#新建文章"></a>新建文章</h3>
<p>搭建完成后就可以写博客文章啦<br>
先CTRL C断开<br>
然后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">"我的第一篇博客文章"</span></span><br><span class="line">//可以看到在以下路径中创建了一个.md文件</span><br><span class="line">INFO  Created: D:\hexo\blog\<span class="built_in">source</span>\_posts\我的第一篇博客文章.md</span><br></pre></td></tr></table></figure>
<p>找到该文件用编辑器编辑(vscode、notepad++等)<br>
编辑完后保存退出<br>
输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>就可以生成文章了<br>
再输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>打开localhost:4000就可以看到刚刚写的博客了</p>
<h2 id="部署到github"><a class="header-anchor" href="#部署到github"></a>部署到github</h2>
<ol>
<li>在GitHub中new repository<br>
仓库名:  “GitHub账号名称”.github.io</li>
<li>安装插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<ol>
<li>修改配置文件<br>
找到blog文件夹中的_config.yml<br>
用编辑器打开<br>
在最后面找到Deployment<br>
修改成如下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/<span class="string">"GitHub账号"</span>/<span class="string">"GitHub账号昵称"</span>.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>保存退出</p>
<ol start="4">
<li>部署</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>然后就可以在GitHub中看到部署的文件了<br>
以后直接在浏览器输入&quot;GitHub账号昵称&quot;.github.io.git<br>
就可以在公网访问个人博客了</p>
<h2 id="更改hexo主题"><a class="header-anchor" href="#更改hexo主题"></a>更改hexo主题</h2>
<ol>
<li>下载主题</li>
</ol>
<p>在GitHub上找到的一个主题<br>
clone到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改配置文件<br>
找到blog文件夹中的_config.yml<br>
用编辑器打开<br>
找到theme<br>
将landscape修改为yilia</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: landscape</span><br></pre></td></tr></table></figure>
<p>保存退出</p>
<ol start="3">
<li>重新生成，启动</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">hexo d//推送到GitHub</span><br></pre></td></tr></table></figure>
<h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2>
<p>㊗️恭喜你看完了这篇文章！</p>
<p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p>
<p>📧 <a href="mailto:yll1671158@163.com">我的邮箱</a></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>

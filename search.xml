<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows定时关机程序</title>
      <link href="/2020/01/02/windows%E5%AE%9A%E6%97%B6%E5%85%B3%E6%9C%BA%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/01/02/windows%E5%AE%9A%E6%97%B6%E5%85%B3%E6%9C%BA%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原因"><a class="header-anchor" href="#原因"></a>原因</h2><blockquote><p>一坐在电脑前就停不下来，别的什么事情都忘了🤦‍♂️</p><p>每次说再看10分钟就不看了，往往1个小时之后都是还坐在电脑前的，尤其是晚上，老是因此熬夜。</p><p>所以干脆搞个定时自动关机，出其不意，一到时间电脑立刻关机，哈哈没想到吧😈</p></blockquote><p>在win10中简单搜了一下，好像没有定时关机的功能。cmd中是可以的啦，下面这个vbs其实也是用的cmd命令</p><a id="more"></a><h2 id="源码"><a class="header-anchor" href="#源码"></a>源码</h2><p>废话不多说，直接上代码。使用vbs实现，还是比较好懂的，我其实也没学过vbs，欢迎大佬批评指正。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> ws=<span class="built_in">createobject</span>(<span class="string">"wscript.shell"</span>)</span><br><span class="line">x=<span class="built_in">msgbox</span>(<span class="string">"确定要关机吗？"</span>,vbYesNo)</span><br><span class="line"><span class="keyword">if</span> x=vbYes <span class="keyword">then</span></span><br><span class="line">    y=<span class="built_in">CDbl</span>(<span class="built_in">inputbox</span>(<span class="string">"输入数字(1~120)：x分钟后关机，取消立刻关机"</span>))</span><br><span class="line">    a=y*<span class="number">60</span></span><br><span class="line">    <span class="keyword">if</span> y&gt;=<span class="number">1</span> <span class="keyword">and</span> y&lt;=<span class="number">120</span> <span class="keyword">then</span></span><br><span class="line">        ws.run <span class="string">"cmd.exe /c shutdown -s -t"</span>&amp;<span class="string">" "</span>&amp;a </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ws.run <span class="string">"cmd.exe /c shutdown -s -t 0"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">msgbox</span>(<span class="string">"有重要的事情还是关掉电脑吧，还有，不要熬夜哦~"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure><p>只有十几行代码，实际上就是使用<code>cmd</code>命令<code>shutdown</code>再加个时间来实现关机</p><p>⭐️声明：上面的代码可以自定义1-120分钟自动关机，如果输入1-120以外的数字或者点取消都会立刻关机。可以改<code>if y&gt;=1 and y&lt;=120</code>中的数字自行增加时间范围。</p><h2 id="使用方法"><a class="header-anchor" href="#使用方法"></a>使用方法</h2><ol><li><p>创建一个文本文件，改扩展名为shutdown.vbs，copy上面代码保存即可</p></li><li><p>双击shutdown.vbs文件运行</p></li></ol><blockquote><p>可以把这个文件放在桌面方便直接运行</p></blockquote><h2 id="效果展示"><a class="header-anchor" href="#效果展示"></a>效果展示</h2><p>输入25后确定（也就是25分钟后关机）</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/20200102235140.png" alt=""></p><h2 id="取消关机"><a class="header-anchor" href="#取消关机"></a>取消关机</h2><p>如果真的有紧急情况需要取消，可以在cmd中输入下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -a</span><br></pre></td></tr></table></figure><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/20200102235355.png" alt=""></p><blockquote><p>一般情况下就不要用了嘛，不然就没意义了。而且如果是立刻关机，应该是来不及取消的🐶</p></blockquote><p>但是windows有时候关机并不是直接就关了，它可能还会提醒有未保存的工作啥的，又给了一次苟延残喘的机会。。。</p><h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2><p>㊗️恭喜你看完了这篇文章！</p>]]></content>
      
      
      <categories>
          
          <category> 不知道分啥类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vbs </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2019/12/13/test/"/>
      <url>/2019/12/13/test/</url>
      
        <content type="html"><![CDATA[<p>这里有一个分割线</p><hr><a id="more"></a><p>I am here!</p><h2 id="测试居中"><a class="header-anchor" href="#测试居中"></a>测试居中</h2><!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --><!-- 其中 class="blockquote-center" 是必须的 --><blockquote class="blockquote-center">blah blah blah</blockquote><!-- 标签 方式，要求版本在0.4.5或以上 --><blockquote class="blockquote-center"><p>blah blah blah</p></blockquote><!-- 标签别名 --><blockquote class="blockquote-center"><p>blah blah blah</p></blockquote><blockquote class="blockquote-center"><p>测试居中</p></blockquote><h2 id="测试emoji"><a class="header-anchor" href="#测试emoji"></a>测试emoji</h2><p>⭐️ 💯 ☑️ 6️⃣ 5️⃣</p><p>🤙</p><h2 id="测试上标下标"><a class="header-anchor" href="#测试上标下标"></a>测试上标下标</h2><p>2<sup>2</sup></p><p>⭐️</p><p>2<sup>2</sup></p><p>H<sub>2</sub>O</p><h2 id="测试公式"><a class="header-anchor" href="#测试公式"></a>测试公式</h2><p>$$<br>2+2=4<br>$$</p><h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2><p>㊗️恭喜你看完了这篇文章！</p><p>如果你有什么疑问和想法，可以直接在下面评论，或者给我发邮件</p><p>📧 <a href="mailto:yll1671158@163.com">我的邮箱</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次给阿里巴巴fastjson修bug的学习经历</title>
      <link href="/2019/12/11/%E4%B8%80%E6%AC%A1%E7%BB%99%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4fastjson%E4%BF%AEbug%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
      <url>/2019/12/11/%E4%B8%80%E6%AC%A1%E7%BB%99%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4fastjson%E4%BF%AEbug%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>fastjson也是我最近有用到的一个开源库</p><p>这是我在B站学习到的，下面附上视频链接</p></blockquote><p><a href="https://www.bilibili.com/video/av77302131" target="_blank" rel="noopener">视频链接</a></p><a id="more"></a><h2 id="找bug标准"><a class="header-anchor" href="#找bug标准"></a>找bug标准</h2><ol><li>bug能复现</li><li>bug比较重要，也就是说很多人都出现过这个bug</li></ol><h2 id="找到bug"><a class="header-anchor" href="#找到bug"></a>找到bug</h2><p>找到的bug：fastjson无法反序列化超出某种限制的类#2779  下面有bug链接</p><p><a href="https://github.com/alibaba/fastjson/issues/2779" target="_blank" rel="noopener">bug链接</a></p><p>首先使用git clone fastjson项目，在idea中打开</p><p>进入test包，发现java.alibaba.fastjson.deserializer包下已经有issue2779的测试类了</p><p>当然，这是up主已经修复的版本啦，我们运行发现并没有报错，哈哈哈</p><h2 id="复现bug"><a class="header-anchor" href="#复现bug"></a>复现bug</h2><p>所以我们使用git回退到up主还没修复成功的版本</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/revertto10_29.png" alt="image-20191211113613380"></p><p>他是11.4修复的，我们回退到下面的10.29</p><p>在此之前，我们可以先把issue2779包里面的两个文件在本地进行修改一下（按回车增加一行就可以），以免回退的时候这个包直接消失了</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/gitreset.png" alt=""></p><p>上图选错了，应该选择Keep→Reset</p><p>看后面的信息就可以知道，选择keep本地修改的文件（也就是刚才修改的issue2779包内的两个文件）会保存下来了，如果选hard就直接暴力删除啦</p><p>之后运行issue2779测试类，终于出现了报错信息</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/illegal%20jump.png" alt="image-20191211115200184"></p><p>然后找这种jdk和这个项目报错信息的交界处</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/more%20error%20info.png" alt="image-20191211115622717"></p><p>也就是com.alibaba.fastjson.parser.deserializer包下面的ASMDeserializerFactory类的createJavaBeanDeserializer方法有问题</p><h2 id="查找问题"><a class="header-anchor" href="#查找问题"></a>查找问题</h2><p>我们定位到这一行，进行断点调试</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/duandiantiaoshi.png" alt="image-20191211115948426"></p><p>查看code变量</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/code.png" alt="image-20191202230532915"></p><blockquote><p>code是一个Java字节码</p><p>所有的.class 文件的前四个字节都是魔数，魔数的固定值为：0xCAFEBABE</p><p>Java有咖啡的意思，程序员的浪漫~</p><p>魔数的固定值是 Java 之父 James Gosling 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡</p></blockquote><h3 id="evaluate-expression表达式求值"><a class="header-anchor" href="#evaluate-expression表达式求值"></a>Evaluate Expression表达式求值</h3><p>在code处右键有个Evaluate Expression，表达式求值</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/evaluate%20expression.png" alt="image-20191202230841162"></p><p>将字节码输出到文件bad.class</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/evaluate-writefile.png" alt="image-20191202231109760"></p><p>可以看到项目这里出现了bad.class文件</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/badclassloca.png" alt="image-20191211120602606"></p><p>很奇怪，我这里idea居然还是可以反编译成功</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/fanbianyibad.png" alt="image-20191211120750776"></p><p>如果是坏的，idea无法反编译，会出现下面的结果，视频中是这样的</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/badclass.png" alt="image-20191202234253689"></p><p>我们可以用一些工具来查看这个坏的字节码文件</p><p>例如下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v bad #Java自带的反编译工具</span><br></pre></td></tr></table></figure><p>但是太长了，在命令行看也不太方便</p><p>我们使用下面的工具classpy</p><h3 id="反编译工具classpy"><a class="header-anchor" href="#反编译工具classpy"></a>反编译工具classpy</h3><p>在GitHub搜索classpy，clone下来，按照readme安装运行</p><p>我是Windows系统，首先进入classpy目录下，点击运行了gradlew.bat文件，然后在当前目录下的命令行输入下面的命令启动这个工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle run</span><br></pre></td></tr></table></figure><p>视频中他的Java版本为11，启动失败了</p><p>使用了jenv命令切换到jdk1.8，我使用的就是jdk1.8  忽略这个步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv shell 1.8  #需要安装jenv</span><br></pre></td></tr></table></figure><p>下面是打开的字节码文件</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/classpybadclass.png" alt="image-20191203001137874"></p><p>由于我们只有Illegal target of jump or branch这个报错信息，这一个线索</p><blockquote><p>下面buildjdk操作太硬核，我没有跟着做😂  感兴趣可以去视频16:45处看看👍</p></blockquote><p>到jdk中寻找此报错信息</p><p>clone openjdk下的jdk项目，全局搜索此报错信息Illegal target of jump or branch</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/errorInfoLocaInJDK.png" alt="Illegal target of jump or branch 报错信息"></p><p>然后他修改了jdk，上面图片中的代码就是修改后的jdk，原来只有报错信息，他自己加上了jump和target，可以提示错误的位置，如下图</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/changeJDK.png" alt="image-20191211131058621"></p><p>然后他自己build了一个jdk👍</p><p>使用自己build的jdk重新运行issue2779，下面是报错信息，deserialze方法第50位置</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/errorInJDK.png" alt="image-20191211131737775"></p><p>在刚才classpy打开的bad.class中找到deserialze方法  字节码  第50个位置是这样的</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/bytecode_50.png" alt="image-20191211124952950"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifeq -32405</span><br></pre></td></tr></table></figure><p>可能是溢出</p><p>查看ifeq的含义，当栈顶int型数值等于0时跳转</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/ifeq.png" alt="image-20191211132443946"></p><p>fastjson有个地方代码没有写好，生成了一个会溢出的跳转指令</p><p>然后根据上下文(50位置上面有个isEnabled)，在源码中找到相应位置</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/errorloca.png" alt="image-20191211125555537"></p><p>进入visitJumpInsn方法，这其实是asm代码（操作字节码的库）</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/asmInterf.png" alt="image-20191211133402454"></p><p>按crtl+alt+B可以进入接口的实现类</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/asmImpl.png" alt="image-20191211133434998"></p><h2 id="解决问题"><a class="header-anchor" href="#解决问题"></a>解决问题</h2><p>然后他觉得，可能是fastjson里面的asm代码版本太老了，想把最新的合并进来，但是由于版本相差7年，失败了</p><p>对比最新的asm代码与fastjson里面的代码</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/changeCode.png" alt="image-20191211133753383"></p><p>这里非常重要，如果越界，可以将IFxxx改为IFNOTxxx  GOTO_W</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/annotation.png" alt="image-20191211175328263"></p><p>最后解决的问题：按照asm的要求，把一个不支持长跳转的ifeq转变成ifnq加goto_w长跳转语句</p><p><a href="https://github.com/alibaba/fastjson/pull/2858" target="_blank" rel="noopener">pr链接</a></p><p>修完bug一定要补一个测试用例！</p><h2 id="视频中提到其他内容"><a class="header-anchor" href="#视频中提到其他内容"></a>视频中提到其他内容</h2><h3 id="字节码的解释："><a class="header-anchor" href="#字节码的解释："></a>字节码的解释：</h3><p>简单写一个测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbcDTO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>,j=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i+j==<span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编译运行，使用ASM Bytecode Viewer插件查看字节码</p><h3 id="asm-bytecode-viewer插件"><a class="header-anchor" href="#asm-bytecode-viewer插件"></a>ASM Bytecode Viewer插件</h3><p>可在idea Plugins中安装</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/asmplugin.png" alt="image-20191208144452139"></p><p>找到main方法</p><p><img src="http://q2cgswswp.bkt.clouddn.com/blog/imgs/JavaBytecode.png" alt="image-20191208144825554"></p><p>每个方法里面有个操作数栈，jvm执行方法时会不停的执行这些指令</p><h3 id="修bug要掌握的东西"><a class="header-anchor" href="#修bug要掌握的东西"></a>修bug要掌握的东西</h3><ol><li>能从用户提供的bug，重现bug</li><li>看栈轨迹，字节码问题出在哪里</li><li>学习使用反编译工具</li><li>错误信息到底是什么问题，读jdk源码（甚至需要build jdk）</li></ol><p>R大的书单RednaxelaFX</p><p>下·</p><h3 id="mybatis需要掌握的内容"><a class="header-anchor" href="#mybatis需要掌握的内容"></a>mybatis需要掌握的内容</h3><ol><li>#{} ${}</li><li>缓存是咋实现的？</li><li>Executor是啥？</li><li>分页是怎么实现的？</li></ol><h2 id="总结一下看这个视频了解到的内容"><a class="header-anchor" href="#总结一下看这个视频了解到的内容"></a>总结一下看这个视频了解到的内容</h2><ul><li><p>Java字节码的magic number  Cofe Babe</p></li><li><p>idea的表达式计算Evaluate Expression</p></li><li><p>学习使用反编译工具javap -v 、classpy</p></li><li><p>ASM Bytecode Viewer插件查看字节码</p></li><li><p>话说我才刚知道idea中快捷键CTRL+Alt+B可以从接口跳转到实现类😂然后Ctrl+U是实现类到接口🤣</p></li><li><p>GitHub中的issue以及pull request</p></li></ul><h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2><p>㊗️恭喜你看完了这篇文章！</p>]]></content>
      
      
      <categories>
          
          <category> LearnJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> LearnJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统实验3 存储管理</title>
      <link href="/2019/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2019/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目的"><a class="header-anchor" href="#实验目的"></a>实验目的</h2><p>理解操作系统存储管理原理</p><blockquote><p>操作系统的发展使得系统完成了大部分的内存管理工作。对于程序员而言，这些内存管理的过程完全透明不可见。因此，程序员开发时从不关心系统如何为自己分配内存，而且永远认为系统可以分配给程序所需要的内存。在程序开发时，程序员真正需要做的就是：申请内存、使用内存、释放内存，其他一概无需过问。</p></blockquote><a id="more"></a><h2 id="实验内容"><a class="header-anchor" href="#实验内容"></a>实验内容</h2><h3 id="程序1"><a class="header-anchor" href="#程序1"></a>程序1</h3><p>申请内存、使用内存以及释放一块内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B17040417.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> * str;</span><br><span class="line"><span class="keyword">if</span> ((str=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"not enough memory to allocate buffer\\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"string is %s\n"</span>,str);</span><br><span class="line"><span class="built_in">free</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序2"><a class="header-anchor" href="#程序2"></a>程序2</h3><p>在打开文件后，通过fstat()获得文件长度，然后通过malloc()系统调用申请响应大小的内存空间，通过read()将文件内容完全读入该内存空间，并显示出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//yanglonglong.c(路径: /opt/yanglonglong.c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd,len;</span><br><span class="line">  <span class="keyword">void</span> *tp;<span class="comment">//void *则为“无类型指针”，可以指向任何数据类型</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">ps</span>;</span></span><br><span class="line">  fd=<span class="built_in">open</span>(<span class="string">"/opt/yanglonglong.c"</span>,<span class="number">0</span>);</span><br><span class="line">  fstat(fd,&amp;ps);</span><br><span class="line">  len=ps.st_size;</span><br><span class="line">  tp=<span class="built_in">malloc</span>(len);</span><br><span class="line">  <span class="built_in">read</span>(fd,tp,len);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,tp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size:%d bytes\n"</span>,len);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点"><a class="header-anchor" href="#知识点"></a>知识点</h2><h3 id="实验指导内容"><a class="header-anchor" href="#实验指导内容"></a>实验指导内容</h3><h4 id="1-内存动态分配函数"><a class="header-anchor" href="#1-内存动态分配函数"></a>1）内存动态分配函数</h4><p>#include &lt;malloc.h&gt;</p><p>void *malloc(size_t size)</p><p>该函数分配指定大小size个字节的内存空间，成功时返回分配内存的指针（即所分配内存的地址）。该内存区域没有清空。</p><h4 id="2-void-free-void-addr"><a class="header-anchor" href="#2-void-free-void-addr"></a>2） void free(void * addr);</h4><p>该函数释放由malloc()分配的内存，addr是要释放内存空间的起始地址，并且addr必须是被以前malloc( )调用返回的。</p><h3 id="网上查阅内容"><a class="header-anchor" href="#网上查阅内容"></a>网上查阅内容</h3><h4 id="malloc的使用方法及注意事项"><a class="header-anchor" href="#malloc的使用方法及注意事项"></a>malloc的使用方法及注意事项</h4><p>使用C语言进行开发的时候,内存管理非常重要,如果内存管理不当,会导致内存泄露,程序无故死机,<br>在C语言中内存管理中,需要使用malloc()和free()两个函数</p><h5 id="1-为什么要使用malloc和free"><a class="header-anchor" href="#1-为什么要使用malloc和free"></a>1 为什么要使用malloc和free ?</h5><p>使用malloc,free可以动态的分配内存和动态释放内存,节约应用程序的运行时,所占用的内存空间,以上也是malloc的优点。</p><h5 id="2-malloc和指针的关系"><a class="header-anchor" href="#2-malloc和指针的关系"></a>2 malloc和指针的关系?</h5><p>void p= *malloc(long num)：该函数分配了num个字节,并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。<br>关于分配失败的原因，应该有多种，比如说空间不足就是一种。<br>void free§： 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存,让这块内存重新交给操作系统管理。<br>综上所述：因为malloc分配成功后返回内存的首地址，在使用中是按地址来进行调用，所以有malloc分配内存的时候，就有指针存在。</p><h5 id="3-一般什么情况下需要用到malloc"><a class="header-anchor" href="#3-一般什么情况下需要用到malloc"></a>3 一般什么情况下需要用到malloc ?</h5><p>在程序运行的时候，可变的array,struct可以用到malloc分配内存，也可以采用分配一个连续的空间 存储一批相同类型的变量。</p><h5 id="4-malloc的用法"><a class="header-anchor" href="#4-malloc的用法"></a>4 malloc的用法</h5><p>程序代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p= (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">//分配100个字符串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == p) <span class="comment">//检测malloc是否分配成功</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用分配空间</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放空间</span></span><br><span class="line">p= <span class="literal">NULL</span>; <span class="comment">//指针释放</span></span><br></pre></td></tr></table></figure><h5 id="5-malloc使用注意事项"><a class="header-anchor" href="#5-malloc使用注意事项"></a>5 malloc使用注意事项</h5><ol><li>malloc内存空间后,需要检查是否分配成功!</li><li>使用完毕后需要释放内存空间，释放后应该把指向这块内存的指针指向NULL,避免再次使用时，出现奇怪的错误现象。</li><li>malloc内存后，不释放会产生内存泄露，多次使用free释放会导致程序报错。</li><li>malloc内存时候，需要对返回的指针类型做强制转换。</li></ol><h4 id="read函数"><a class="header-anchor" href="#read函数"></a>read函数</h4><p>用read函数读取数组中的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>第一个参数说明的是从0开始读取<br>第二个参数是：要读取的数组buf<br>第三个参数是：要读5个</p><p>总结：从第0个开始读取buf中的5个元素（连续的）</p><h4 id="fstat"><a class="header-anchor" href="#fstat"></a>fstat</h4><p>功能：<br>获得文件或共享内存区的信息<br>头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntk.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数原形：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name,struct stat *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：<br>file_name          文件名<br>buf                     stat结构<br>返回值：<br>成功返回0，出错返回-1<br>对于普通文件stat结构可以获得12个以上的成员信息，然而当fd指代一个共享内存区对象时，只有四个成员含有信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>&#123;</span></span><br><span class="line"><span class="keyword">mode_t</span> st_mode;</span><br><span class="line"><span class="keyword">uid_t</span> st_uid;</span><br><span class="line"><span class="keyword">gid_t</span> st_gid;</span><br><span class="line"><span class="keyword">off_t</span> st_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="exit-函数"><a class="header-anchor" href="#exit-函数"></a>exit()函数:</h4><p>所在头文件：<strong>stdlib.h</strong><br>功 能: 关闭所有文件，终止正在执行的进程。<br>exit(1)表示异常退出.这个1是返回给操作系统的。<br>exit(x)（x不为0）都表示异常退出<br>exit(0)表示正常退出<br>exit()的参数会被传递给一些操作系统，包括UNIX,Linux,和MS DOS，以供其他程序使用。<br><strong>stdlib.h</strong>: void exit(int status);<br>参 数 : status //程序退出的返回值.</p><h4 id="exit函数和return函数的主要区别："><a class="header-anchor" href="#exit函数和return函数的主要区别："></a>exit函数和return函数的主要区别：</h4><p>1）exit用于在程序运行的过程中随时结束程序，exit的参数是返回给OS的。main函数结束时也会隐式地调用exit函数。exit函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile()创建的临时文件。exit是结束一个进程，它将删除进程使用的内存空间，同时把错误信息返回父进程,而return是返回函数值并退出函数。通常情况：</p><ul><li><p>exit(0)表示程序正常,</p></li><li><p>exit(1)和exit(-1)表示程序异常退出，exit(2)表示表示系统找不到指定的文件。</p></li></ul><p>在整个程序中，只要调用exit就结束（当前进程或者在main时候为整个程序）。</p><p>2）return是语言级别的，它表示了调用堆栈的返回；return( )是当前函数返回，当然如果是在主函数main, 自然也就结束当前进程了，如果不是，那就是退回上一层调用。在多个进程时。如果有时要检测上个进程是否正常退出。就要用到上个进程的返回值，依次类推。而exit是系统调用级别的，它表示了一个进程的结束。</p><p>3）exit函数是退出应用程序，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息。</p><p>4）和机器和操作系统有关的一般是： 0为正常退出，非0为非正常退出；</p><h4 id="进程环境与进程控制"><a class="header-anchor" href="#进程环境与进程控制"></a>进程环境与进程控制</h4><p>​exit(int n)其实就是直接退出程序，因为默认的标准程序入口为 int main(int argc, char** argv)，返回值是int型的。一般在shell下面，运行一个程序，然后使用命令echo $?就能得到该程序的返回值，也就是退出值，在main()里面，你可以用return n，也能够直接用exit(n)来做。unix默认的正确退出是返回0，错误返回非0。</p><p>理论上exit可以返回小于256的任何整数。返回的不同数值主要是给调用者作不同处理的。</p><p>单独的进程是返回给操作系统的。如果是多进程，是返回给父进程的。父进程里面调用waitpid()等函数得到子进程退出的状态，以便作不同处理。根据相应的返回值来让调用者作出相应的处理.总的说来，exit（）就是当前进程把控制权返回给调用该程序的程序,括号里的是返回值,告诉调用程序该程序的运行状态。</p><h5 id="1-进程的开始："><a class="header-anchor" href="#1-进程的开始："></a>1） 进程的开始：</h5><p>C程序是从main函数开始执行, 原型如下:int main(int argc, char *argv[]);通常main的返回值是int型, 正确返回0。如果main的返回值为void, 某些编译器会给出警告, 此时main的返回值通常是0。</p><h5 id="2-进程终止："><a class="header-anchor" href="#2-进程终止："></a>2）进程终止：</h5><p>C程序的终止分为两种: 正常终止和异常终止。正常终止分为: return, exit, _exit, _Exit, pthreade_exit。异常中指分为: abort, SIGNAL, 线程响应取消。<br>主要说一下正常终止的前4种, 即exit系列函数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;   </span></span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><p>以上3个函数的区别是:exit()(或return 0)会调用终止处理程序和用户空间的标准I/O清理程序(如fclose), <em>exit和</em> Exit不调用而直接由内核接管进行清理。<strong>因此, 在main函数中exit(0)等价于return 0</strong></p><h5 id="3-atexit终止处理程序："><a class="header-anchor" href="#3-atexit终止处理程序："></a>3） atexit终止处理程序：</h5><p>ISO C规定, 一个进程最多可登记32个终止处理函数, 这些函数由exit按登记相反的顺序自动调用。如果同一函数登记多次, 也会被调用多次。<br>原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>其中参数是一个函数指针, 指向终止处理函数, 该函数无参无返回值。atexit函数本身成功调用后返回0。</p><p>以下面的程序为例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myexit1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"first exit handler\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myexit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"second exit handler\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atexit(my_exit2)；</span><br><span class="line">  atexit(my_exit1)； </span><br><span class="line"></span><br><span class="line">atexit(my_exit1)；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main is done\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;a.out</span><br><span class="line">main is done</span><br><span class="line">first exit handler</span><br><span class="line">first exit handler</span><br><span class="line">second exit handler</span><br></pre></td></tr></table></figure><p>注意上面的结果，可以发现这些函数由exit按登记相反的顺序自动调用（先myexit1后myexit2）。如果同一函数登记多次, 也会被调用多次（如这里的myexit1）。而这些处理函数都是在程序退出的时候利用atexit函数调用了这些处理函数。但是如果用_exit()退出程序，则它不关闭任何文件，不清除任何缓冲器、也不调用任何终止函数！</p><h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2><p>㊗️恭喜你看完了这篇文章！</p>]]></content>
      
      
      <categories>
          
          <category> 实验报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学复习</title>
      <link href="/2019/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://learnopengl-cn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">OpenGL官方文档链接</a></p><blockquote><p>此博客用来学习OpenGL知识以及相关函数的学习，不包含完整项目的源码</p></blockquote><a id="more"></a><h2 id="起步"><a class="header-anchor" href="#起步"></a>起步</h2><p>开发环境vs2017</p><p>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。</p><p>OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在Windows上会是类似这样：</p><p>了解即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*GL_GENBUFFERS)</span> <span class="params">(GLsizei, GLuint*)</span></span>;</span><br><span class="line"><span class="comment">// 找到正确的函数并赋值给函数指针</span></span><br><span class="line">GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress(<span class="string">"glGenBuffers"</span>);</span><br><span class="line"><span class="comment">// 现在函数可以被正常调用了</span></span><br><span class="line">GLuint <span class="built_in">buffer</span>;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;<span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure><p>可以看到代码非常复杂，而且很繁琐，我们需要对每个可能使用的函数都要重复这个过程。幸运的是，有些库能简化此过程，其中<strong>GLEW</strong>是目前最新，也是最流行的库。</p><p>GLEW是OpenGL Extension Wrangler Library的缩写，它能解决我们上面提到的那个繁琐的问题。因为GLEW也是一个库，我们同样需要构建并将其链接进工程。</p><h3 id="静态链接与动态链接"><a class="header-anchor" href="#静态链接与动态链接"></a>静态链接与动态链接</h3><p><strong>静态</strong>(Static)链接是指编译时就将库代码里的内容整合进你的二进制文件。优点就是你不需要管理额外的文件了，只需要发布你单独的一个二进制文件就行了。缺点就是你的可执行文件会变得更大，另外当库有升级版本时，你必须重新进行编译整个程序。</p><p><strong>动态</strong>(Dynamic)链接是指一个库通过<code>.dll</code>或<code>.so</code>的方式存在，它的代码与你的二进制文件的代码是分离的。优点是使你的二进制文件大小变小并且更容易升级，缺点是你最终发布程序时必须带上这些DLL。</p><p>静态链接GLEW，必须在包含GLEW头文件之前定义预处理器宏<code>GLEW_STATIC</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="创建窗口"><a class="header-anchor" href="#创建窗口"></a>创建窗口</h2><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//GLEW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GLFW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> GLint WIDTH = <span class="number">800</span>, HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">glfwInit();<span class="comment">//初始化glfw</span></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//配置GLFW</span></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//配置GLFW</span></span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">// must for Mac</span></span><br><span class="line">glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//glfwCreateWindow函数需要窗口的宽和高作为它的前两个参数；第三个参数表示这个窗口的名称（标题）；最后两个参数我们暂时忽略，先设置为空指针就行。</span></span><br><span class="line">GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, <span class="string">"Learn OpenGL"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nullptr</span> == window)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">glfwTerminate();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GLEW是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLEW</span></span><br><span class="line">glewExperimental = GL_TRUE;</span><br><span class="line"><span class="keyword">if</span> (GLEW_OK != glewInit()) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialise GLEW"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> screenWidth, screenHeight;</span><br><span class="line">glfwGetFramebufferSize(window, &amp;screenWidth, &amp;screenHeight);</span><br><span class="line">    <span class="comment">/*可以通过调用glViewport函数来设置窗口的维度(Dimension)</span></span><br><span class="line"><span class="comment">    前两个参数控制窗口左下角的位置；第三个和第四个参数控制渲染窗口的宽度和高度（像素）*/</span></span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, screenWidth, screenHeight);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*我们可不希望只绘制一个图像之后我们的应用程序就立即退出并关闭窗口。</span></span><br><span class="line"><span class="comment">    因此，我们需要在程序中添加一个while循环，它能在我们让GLFW退出前一直保持运行。*/</span></span><br><span class="line">    <span class="comment">//glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后游戏循环便结束了，之后为我们就可以关闭应用程序了。</span></span><br><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等），然后调用对应的回调函数（可以通过回调方法手动设置）。我们一般在游戏循环的开始调用事件处理函数。</span></span><br><span class="line">glfwPollEvents();</span><br><span class="line">glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">//glfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上</span></span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//当游戏循环结束后我们需要正确释放/删除之前的分配的所有资源。我们可以在main函数的最后调用glfwTerminate函数来释放GLFW分配的内存</span></span><br><span class="line">glfwTerminate();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三角形"><a class="header-anchor" href="#三角形"></a>三角形</h2><p>OpenGL的大部分工作都是把3D坐标转变为适应你屏幕的2D像素。</p><p>3D坐标转为2D坐标的处理过程是由OpenGL的<strong>图形渲染管线</strong>（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。</p><h3 id="顶点着色器"><a class="header-anchor" href="#顶点着色器"></a>顶点着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position.x, position.y, position.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in</code>关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)</p><p>图形渲染管线的第一个部分是**顶点着色器(**Vertex Shader)，它把一个单独的顶点作为输入。目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><p><strong>图元装配</strong>(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入，并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p><p>OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把<strong>所有的</strong>3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。</p><p>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以<strong>标准化设备坐标</strong>的形式（OpenGL的可见区域）定义为一个<code>GLfloat</code>数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们渲染的是一个2D三角形，将它顶点的z坐标设置为0.0。</p><p>定义顶点数据以后，我们会把它作为输入发送顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p><h3 id="顶点缓存对象vbo"><a class="header-anchor" href="#顶点缓存对象vbo"></a>顶点缓存对象VBO</h3><p>我们通过<strong>顶点缓冲对象</strong>(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存(通常被称为显存)中<strong>储存大量顶点</strong>。</p><p>顶点缓冲对象是我们在OpenGL教程中第一个OpenGL对象。这个缓冲有一个独一无二的ID，我们可以使用<u><em>glGenBuffers</em></u>函数和一个缓冲ID生成一个VBO对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br></pre></td></tr></table></figure><p>顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER</p><p>我们可以使用<u><em>glBindBuffer</em></u>函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br></pre></td></tr></table></figure><p>从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用<u><em>glBufferData</em></u>函数，它会把之前定义的顶点数据复制到缓冲的内存中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。</p><ol><li><p>第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。</p></li><li><p>第二个参数指定传输数据的大小(以字节为单位)；用一个简单的<code>sizeof</code>计算出顶点数据大小就行。</p></li><li><p>第三个参数是我们希望发送的实际数据。</p></li><li><p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p></li></ol><ul><li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li><li>GL_DYNAMIC_DRAW：数据会被改变很多。</li><li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li></ul><p>我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为<code>GLuint</code>，然后用<u><em>glCreateShader</em></u>创建这个着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure><p>我们把需要创建的着色器类型以参数形式提供给glCreateShader。由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER。</p><p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p>glShaderSource函数把</p><p>要编译的着色器对象作为第一个参数。</p><p>第二参数指定了传递的源码字符串数量，这里只有一个。</p><p>第三个参数是顶点着色器真正的源码，</p><p>第四个参数我们先设置为<code>NULL</code>。</p><h3 id="片段着色器"><a class="header-anchor" href="#片段着色器"></a>片段着色器</h3><p>片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器全是关于计算你的像素最后的颜色输出。</p><p>片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    color = <span class="type">vec4</span>(<span class="number">1.0</span>f, <span class="number">0.5</span>f, <span class="number">0.2</span>f, <span class="number">1.0</span>f);<span class="comment">//第四个参数 1.0代表完全不透明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>out</code>关键字声明输出变量</p><p>编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLuint fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, null);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure><p>两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。</p><h3 id="着色器程序"><a class="header-anchor" href="#着色器程序"></a>着色器程序</h3><p>着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。</p><p>创建一个程序对象很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint shaderProgram;</span><br><span class="line">shaderProgram &#x3D; glCreateProgram();</span><br></pre></td></tr></table></figure><p>glCreateProgram函数创建一个程序，并返回新创建程序对象的ID引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用glLinkProgram链接它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>我们把着色器附加到了程序上，然后用glLinkProgram链接。</p><p>得到的结果就是一个程序对象，我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。</p><p>对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><h3 id="链接顶点属性"><a class="header-anchor" href="#链接顶点属性"></a>链接顶点属性</h3><p>顶点着色器允许我们指定任何以顶点属性为形式的输入。意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。</p><p>我们的顶点缓冲数据会被解析为下面这样子：</p><p><img src="https://learnopengl-cn.readthedocs.io/zh/latest/img/01/04/vertex_attribute_pointer.png" alt="img"></p><ul><li>位置数据被储存为32-bit（4字节）浮点值。</li><li>每个位置包含3个这样的值。</li><li>在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列。</li><li>数据中第一个值在缓冲开始的位置。</li></ul><p>有了这些信息我们就可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>glVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们：</p><ul><li>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为<code>0</code>。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入<code>0</code>。</li><li>第二个参数指定顶点属性的大小。顶点属性是一个<code>vec3</code>，它由3个值组成，所以大小是3。</li><li>第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中<code>vec*</code>都是由浮点数值组成的)。</li><li>下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。</li><li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个<code>GLfloat</code>之后，我们把步长设置为<code>3 * sizeof(GLfloat)</code>。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子(译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节)。</li><li>最后一个参数的类型是<code>GLvoid*</code>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</li></ul><blockquote><p>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVetexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVetexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性<code>0</code>现在会链接到它的顶点数据。</p></blockquote><p>在OpenGL中绘制一个物体，代码会像是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 复制顶点数组到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 1. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line"><span class="comment">//glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 当我们渲染一个物体时要使用着色器程序</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// 3. 绘制物体</span></span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure><h3 id="顶点数组对象vao"><a class="header-anchor" href="#顶点数组对象vao"></a>顶点数组对象VAO</h3><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。</p><p>一个顶点数组对象会储存以下这些内容：</p><ul><li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li><li>通过glVertexAttribPointer设置的顶点属性配置。</li><li>通过<code>glVertexAttribPointer</code>调用进行的顶点缓冲对象与顶点属性链接。</li></ul><p>创建一个VAO和创建一个VBO很类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint VAO;</span><br><span class="line">glGenVertexArrays(1, &amp;VAO);</span><br></pre></td></tr></table></figure><p>要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//4. 解绑VAO</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代（游戏循环中） :: ..</span></span><br><span class="line"><span class="comment">// 5. 绘制物体</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>要想绘制我们想要的物体，OpenGL给我们提供了glDrawArrays函数，它使用当前激活的着色器，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line">glBindVertexArray(0);</span><br></pre></td></tr></table></figure><p>glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。第二个参数指定了顶点数组的起始索引，我们这里填<code>0</code>。最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。</p><h3 id="索引缓冲对象"><a class="header-anchor" href="#索引缓冲对象"></a>索引缓冲对象</h3><p>在渲染顶点这一话题上我们还有最有一个需要讨论的东西——索引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertices[] &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一个三角形</span><br><span class="line">    0.5f, 0.5f, 0.0f,   &#x2F;&#x2F; 右上角</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f,  &#x2F;&#x2F; 左上角</span><br><span class="line">    &#x2F;&#x2F; 第二个三角形</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f   &#x2F;&#x2F; 左上角</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，有几个顶点叠加了。我们指定了<code>右下角</code>和<code>左上角</code>两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果OpenGL提供这个功能就好了，对吧？</p><p>很幸运，索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（独一无二的）顶点，和绘制出矩形所需的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertices[] &#x3D; &#123;</span><br><span class="line">    0.5f, 0.5f, 0.0f,   &#x2F;&#x2F; 右上角</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f   &#x2F;&#x2F; 左上角</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GLuint indices[] &#x3D; &#123; &#x2F;&#x2F; 注意索引从0开始! </span><br><span class="line">    0, 1, 3, &#x2F;&#x2F; 第一个三角形</span><br><span class="line">    1, 2, 3  &#x2F;&#x2F; 第二个三角形</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以看到，当时用索引的时候，我们只定义了4个顶点，而不是6个。下一步我们需要创建索引缓冲对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint EBO;</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br></pre></td></tr></table></figure><p>与VBO类似，我们先绑定EBO然后用glBufferData把索引复制到缓冲里。同样，和VBO类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>要注意的是，我们传递了GL_ELEMENT_ARRAY_BUFFER当作缓冲目标。最后一件要做的事是用glDrawElements来替换glDrawArrays函数，来指明我们从索引缓冲渲染。使用glDrawElements时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span><br></pre></td></tr></table></figure><p>第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。第三个参数是索引的类型，这里是GL_UNSIGNED_INT。最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。</p><p>glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。</p><p>最后的初始化和绘制代码现在看起来像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码 :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 设定顶点属性指针</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 4. 解绑VAO（不是EBO！）</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（游戏循环中） :: ..</span></span><br><span class="line"></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="colorful🔺"><a class="header-anchor" href="#colorful🔺"></a>colorful🔺</h3><p>把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用<code>layout</code>标识符来把color属性的位置值设置为1：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position; <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> color;    <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = color; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们不再使用uniform来传递片段的颜色了，现在使用<code>ourColor</code>输出变量，我们必须再修改一下片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    color = <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。更新后的VBO内存中的数据现在看起来像这样：</p><p><img src="https://learnopengl-cn.readthedocs.io/zh/latest/img/01/05/vertex_attribute_pointer_interleaved.png" alt="img"></p><p>知道了现在使用的布局，我们就可以使用glVertexAttribPointer函数更新顶点格式，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)(<span class="number">3</span>* <span class="keyword">sizeof</span>(GLfloat)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>glVertexAttribPointer函数的前几个参数比较明了。这次我们配置属性位置值为1的顶点属性。颜色值有3个float那么大，我们不去标准化这些值。</p><p>由于我们现在有了两个顶点属性，我们不得不重新计算<strong>步长</strong>值。为获得数据队列中下一个属性值（比如位置向量的下个<code>x</code>分量）我们必须向右移动6个float，其中3个是位置值，另外3个是颜色值。这使我们的步长值为6乘以float的字节数（=24字节）。<br>同样，这次我们必须指定一个偏移量。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以偏移量就是<code>3 * sizeof(GLfloat)</code>，用字节来计算就是12字节。</p><p>运行程序你应该会看到如下结果：</p><p><img src="https://learnopengl-cn.readthedocs.io/zh/latest/img/01/05/shaders3.png" alt="img"></p><h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2><p>㊗️恭喜你看完了这篇文章！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2019/09/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2019/09/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建博客"><a class="header-anchor" href="#搭建博客"></a>搭建博客</h2><ol><li>安装node和git</li></ol><p>在Windows中查看是否成功安装node<br>win + R 输入cmd打开命令行窗口<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>回车后看到版本号</p><a id="more"></a><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>同样看到版本号即表示安装成功</p><p>2.安装hexo</p><ol><li>安装cnpm</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装成功后输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm</span><br></pre></td></tr></table></figure><p>可以看到相应信息</p><ol start="2"><li>安装hexo</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装成功后可输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>验证是否成功</p><p>3.选择一个路径，新建文件夹blog(当然也可以用其他名称)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line"><span class="built_in">cd</span> blog     //进入blog文件夹</span><br><span class="line">hexo init  //初始化文件夹，漫长的等待。。。</span><br></pre></td></tr></table></figure><p>如果出现了错误，可以删掉blog文件夹，从新建文件夹blog重新开始<br>成功后可以看到blog文件夹下生成了一些文件<br>然后就可以启动博客了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>可以看到输出如下信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>在浏览器输入localhost:4000回车就可以看到博客了<br>如下图<br><img src="https://img-blog.csdnimg.cn/20190927224717553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVweWFuZw==,size_16,color_FFFFFF,t_70" alt="博客页面"><br>默认生成了一篇Hello World的文章</p><h3 id="新建文章"><a class="header-anchor" href="#新建文章"></a>新建文章</h3><p>搭建完成后就可以写博客文章啦<br>先CTRL C断开<br>然后输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"我的第一篇博客文章"</span></span><br><span class="line">//可以看到在以下路径中创建了一个.md文件</span><br><span class="line">INFO  Created: D:\hexo\blog\<span class="built_in">source</span>\_posts\我的第一篇博客文章.md</span><br></pre></td></tr></table></figure><p>找到该文件用编辑器编辑(vscode、notepad++等)<br>编辑完后保存退出<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>就可以生成文章了<br>再输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>打开localhost:4000就可以看到刚刚写的博客了</p><h2 id="部署到github"><a class="header-anchor" href="#部署到github"></a>部署到github</h2><ol><li>在GitHub中new repository<br>仓库名:  “GitHub账号名称”.github.io</li><li>安装插件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><ol><li>修改配置文件<br>找到blog文件夹中的_config.yml<br>用编辑器打开<br>在最后面找到Deployment<br>修改成如下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/<span class="string">"GitHub账号"</span>/<span class="string">"GitHub账号昵称"</span>.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>保存退出</p><ol start="4"><li>部署</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后就可以在GitHub中看到部署的文件了<br>以后直接在浏览器输入&quot;GitHub账号昵称&quot;.github.io.git<br>就可以在公网访问个人博客了</p><h2 id="更改hexo主题"><a class="header-anchor" href="#更改hexo主题"></a>更改hexo主题</h2><ol><li>下载主题</li></ol><p>在GitHub上找到的一个主题<br>clone到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件<br>找到blog文件夹中的_config.yml<br>用编辑器打开<br>找到theme<br>将landscape修改为yilia</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: landscape</span><br></pre></td></tr></table></figure><p>保存退出</p><ol start="3"><li>重新生成，启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">hexo d//推送到GitHub</span><br></pre></td></tr></table></figure><h2 id="the-end"><a class="header-anchor" href="#the-end"></a>The End</h2><p>㊗️恭喜你看完了这篇文章！</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
